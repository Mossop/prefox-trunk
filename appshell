# HG changeset patch
# User Dave Townsend <dtownsend@oxymoronical.com>
# Date 1273018185 25200
# Node ID 871ac1800953f7e196d163aeffff876ba17c55c0
# Parent  411ee064b3cb7c40df0bef3fe8bce3e3778fe794
[palm] Make the app shell the manager for the widget info and support rotating based on orientation

diff --git a/widget/src/webos/nsAppShell.cpp b/widget/src/webos/nsAppShell.cpp
--- a/widget/src/webos/nsAppShell.cpp
+++ b/widget/src/webos/nsAppShell.cpp
@@ -41,8 +41,9 @@
 #include "nsThreadUtils.h"
 #include "prlog.h"
 #include "prenv.h"
+#include "nsIAppStartup.h"
 
-#include <pthread.h>
+#define ORIENTATION_THRESHOLD 10000
 
 using namespace mozilla;
 
@@ -50,7 +51,8 @@ PRLogModuleInfo* gAppShellLog = nsnull;
 
 nsAppShell *nsAppShell::gAppShell = nsnull;
 
-nsAppShell::nsAppShell()
+nsAppShell::nsAppShell() :
+  mOrientation(PDL_ORIENTATION_0)
 {
 #if defined(PR_LOGGING)
     if (!gAppShellLog) {
@@ -58,12 +60,39 @@ nsAppShell::nsAppShell()
     }
 #endif
 
+    PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("SDL Init"));
+    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK) < 0) {
+        NS_ABORT_IF_FALSE(PR_FALSE, "Unable to initialise SDL");
+    }
+    PDL_Init(0);
+
+    const SDL_VideoInfo *info = SDL_GetVideoInfo();
+    mScreenBounds.width = info->current_w;
+    mScreenBounds.height = info->current_h;
+    PR_LOG(gAppShellLog, PR_LOG_DEBUG,
+           ("Screen is % 3dx% 3d", mScreenBounds.width, mScreenBounds.height));
+
+#ifdef USE_GL
+    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
+#endif
+    SDL_EnableUNICODE(1);
+    PDL_BannerMessagesEnable(PDL_TRUE);
+    PDL_ScreenTimeoutEnable(PDL_TRUE);
+
+    mJoystick = SDL_JoystickOpen(0);
+    if (!mJoystick)
+        PR_LOG(gAppShellLog, PR_LOG_WARN, ("Unable to open accelerometer"));
+
     gAppShell = this;
 }
 
 nsAppShell::~nsAppShell()
 {
     PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Destroy"));
+
+    PDL_Quit();
+    SDL_Quit();
+
     gAppShell = nsnull;
 }
 
@@ -76,6 +105,56 @@ nsAppShell::Init()
 }
 
 void
+nsAppShell::ChangeOrientation(PDL_Orientation aNewOrientation)
+{
+    if (aNewOrientation == PDL_ORIENTATION_270) {
+        aNewOrientation = PDL_ORIENTATION_90;
+    }
+
+    if (aNewOrientation == PDL_ORIENTATION_180) {
+        aNewOrientation = PDL_ORIENTATION_0;
+    }
+
+    if (mOrientation == aNewOrientation) {
+        return;
+    }
+
+    PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Changing orientation"));
+
+    PRInt32 temp = mScreenBounds.width;
+    mScreenBounds.width = mScreenBounds.height;
+    mScreenBounds.height = temp;
+    PDL_SetOrientation(aNewOrientation);
+    mOrientation = aNewOrientation;
+
+    SDL_Event sdlevt;
+    sdlevt.type = SDL_VIDEORESIZE;
+    sdlevt.resize.type = SDL_VIDEORESIZE;
+    sdlevt.resize.w = mScreenBounds.width;
+    sdlevt.resize.h = mScreenBounds.height;
+    SDL_PushEvent(&sdlevt);
+}
+
+void
+nsAppShell::CheckOrientation()
+{
+    Sint16 x = SDL_JoystickGetAxis(mJoystick, 0);
+    Sint16 y = SDL_JoystickGetAxis(mJoystick, 1);
+
+    Sint16 absx = abs(x);
+    Sint16 absy = abs(y);
+
+    if (abs(absy - absx) > ORIENTATION_THRESHOLD) {
+        if (absx > absy) {
+            ChangeOrientation(x < 0 ? PDL_ORIENTATION_270 : PDL_ORIENTATION_90);
+        }
+        else {
+            ChangeOrientation(y < 0 ? PDL_ORIENTATION_180 : PDL_ORIENTATION_0);
+        }
+    }
+}
+
+void
 nsAppShell::ScheduleNativeEventCallback()
 {
 }
@@ -102,6 +181,8 @@ nsAppShell::ShouldCoalesceEvent(SDL_Even
         }
         break;
     case SDL_MOUSEMOTION:
+    case SDL_JOYAXISMOTION:
+    case SDL_VIDEORESIZE:
         return PR_TRUE;
     }
 
@@ -125,7 +206,7 @@ nsAppShell::CanCoalesceEvents(SDL_Event 
 PRBool
 nsAppShell::ProcessNextNativeEvent(PRBool mayWait)
 {
-    PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("ProcessNextNativeEvent(%d)", mayWait));
+    //PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("ProcessNextNativeEvent(%d)", mayWait));
 
     SDL_Event event;
     int count = SDL_PollEvent(&event);
@@ -133,8 +214,6 @@ nsAppShell::ProcessNextNativeEvent(PRBoo
     if (count == 0)
         return PR_FALSE;
 
-    PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Got event type %d", event.type));
-
     if (ShouldCoalesceEvent(event))
     {
         // Coalesce any events in the queue
@@ -151,7 +230,22 @@ nsAppShell::ProcessNextNativeEvent(PRBoo
         }
     }
 
-    nsWindow::OnGlobalSDLEvent(&event);
+    switch (event.type) {
+    case SDL_JOYAXISMOTION:
+        CheckOrientation();
+        break;
+    case SDL_QUIT:
+    {
+        PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Quit requested"));
+        nsCOMPtr<nsIAppStartup> appService = do_GetService("@mozilla.org/toolkit/app-startup;1");
+        if (appService)
+            appService->Quit(nsIAppStartup::eForceQuit);
+        break;
+    }
+    default:
+        PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Got event type %d", event.type));
+        nsWindow::OnGlobalSDLEvent(&event);
+    }
 
     return PR_TRUE;
 }
diff --git a/widget/src/webos/nsAppShell.h b/widget/src/webos/nsAppShell.h
--- a/widget/src/webos/nsAppShell.h
+++ b/widget/src/webos/nsAppShell.h
@@ -40,13 +40,14 @@
 #define nsAppShell_h__
 
 #include "nsBaseAppShell.h"
+#include "gfxContext.h"
 
+#include "PDL.h"
 #include "SDL.h"
 
 #define WEBOS_EVENT_REDRAW 1
 
-class nsAppShell :
-    public nsBaseAppShell
+class nsAppShell : public nsBaseAppShell
 {
 public:
     static nsAppShell *gAppShell;
@@ -56,12 +57,20 @@ public:
     nsresult Init();
     static void ScheduleRedraw();
 
+    gfxIntSize mScreenBounds;
+
 protected:
+    SDL_Joystick *mJoystick;
+    PDL_Orientation mOrientation;
+
+    virtual ~nsAppShell();
+
+    void ChangeOrientation(PDL_Orientation aNewOrientation);
+    void CheckOrientation();
     virtual void ScheduleNativeEventCallback();
     PRBool ShouldCoalesceEvent(SDL_Event &event);
     PRBool CanCoalesceEvents(SDL_Event &event1, SDL_Event &event2);
     virtual PRBool ProcessNextNativeEvent(PRBool mayWait);
-    virtual ~nsAppShell();
 };
 
 #endif // nsAppShell_h__
diff --git a/widget/src/webos/nsScreenManager.cpp b/widget/src/webos/nsScreenManager.cpp
--- a/widget/src/webos/nsScreenManager.cpp
+++ b/widget/src/webos/nsScreenManager.cpp
@@ -40,14 +40,10 @@
 #include "nsScreenManager.h"
 #include "nsWindow.h"
 #include "prlog.h"
-
-#include "PDL.h"
-#include "SDL.h"
+#include "nsAppShell.h"
 
 PRLogModuleInfo* gScreenManagerLog = nsnull;
 
-static gfxIntSize gScreenBounds;
-
 NS_IMPL_ISUPPORTS1(nsWebOSScreen, nsIScreen)
 
 nsWebOSScreen::nsWebOSScreen(void *nativeScreen)
@@ -61,13 +57,11 @@ nsWebOSScreen::~nsWebOSScreen()
 NS_IMETHODIMP
 nsWebOSScreen::GetRect(PRInt32 *outLeft, PRInt32 *outTop, PRInt32 *outWidth, PRInt32 *outHeight)
 {
-    const SDL_VideoInfo *info = SDL_GetVideoInfo();
-
     *outLeft = 0;
     *outTop = 0;
 
-    *outWidth = info->current_w;
-    *outHeight = info->current_h;
+    *outWidth = nsAppShell::gAppShell->mScreenBounds.width;
+    *outHeight = nsAppShell::gAppShell->mScreenBounds.width;
 
     return NS_OK;
 }
@@ -116,47 +110,6 @@ nsScreenManager::~nsScreenManager()
     PR_LOG(gScreenManagerLog, PR_LOG_DEBUG, ("Destroy"));
 }
 
-gfxIntSize
-nsScreenManager::GetBounds()
-{
-#if defined(PR_LOGGING)
-    if (!gScreenManagerLog) {
-        gScreenManagerLog = PR_NewLogModule("nsScreenManager");
-    }
-#endif
-
-    if (SDL_WasInit(SDL_INIT_VIDEO) == 0) {
-        PR_LOG(gScreenManagerLog, PR_LOG_DEBUG, ("SDL Init"));
-        SDL_Init(SDL_INIT_VIDEO | SDL_INIT_NOPARACHUTE);
-#ifdef USE_GL
-        SDL_Surface *surface = SDL_SetVideoMode(0, 0, 0, SDL_OPENGL);
-#else
-        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
-        SDL_Surface *surface = SDL_SetVideoMode(0, 0, 0, 0);
-#endif
-        if (!surface) {
-            PR_LOG(gScreenManagerLog, PR_LOG_ERROR, ("Could not get an SDL surface: %s", SDL_GetError()));
-        }
-        NS_ABORT_IF_FALSE(surface, "Could not get an SDL surface");
-
-
-        gScreenBounds.width = surface->w;
-        gScreenBounds.height = surface->h;
-
-        PR_LOG(gScreenManagerLog, PR_LOG_DEBUG,
-               ("Screen is % 3dx% 3d, %d bpp, hw(%d) db(%d)",
-                gScreenBounds.width, gScreenBounds.height, surface->format->BitsPerPixel,
-                surface->flags & SDL_HWSURFACE, surface->flags & SDL_DOUBLEBUF));
-
-        SDL_EnableUNICODE(1);
-        PDL_BannerMessagesEnable(PDL_TRUE);
-        PDL_GesturesEnable(PDL_TRUE);
-        PDL_ScreenTimeoutEnable(PDL_TRUE);
-    }
-
-    return gScreenBounds;
-}
-
 NS_IMETHODIMP
 nsScreenManager::GetPrimaryScreen(nsIScreen **outScreen)
 {
diff --git a/widget/src/webos/nsScreenManager.h b/widget/src/webos/nsScreenManager.h
--- a/widget/src/webos/nsScreenManager.h
+++ b/widget/src/webos/nsScreenManager.h
@@ -45,8 +45,6 @@
 #include "nsIScreenManager.h"
 #include "nsIScreen.h"
 
-#include "gfxContext.h"
-
 class nsWebOSScreen :
     public nsIScreen
 {
@@ -68,7 +66,6 @@ public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSISCREENMANAGER
 
-    static gfxIntSize GetBounds();
 protected:
     nsCOMPtr<nsIScreen> mOneScreen;
 };
diff --git a/widget/src/webos/nsWindow.cpp b/widget/src/webos/nsWindow.cpp
--- a/widget/src/webos/nsWindow.cpp
+++ b/widget/src/webos/nsWindow.cpp
@@ -52,8 +52,6 @@
 
 #include "nsTArray.h"
 
-#include "SDL/SDL.h"
-
 #ifdef USE_GL
 /* OpenGL */
 #include <GLES2/gl2.h>
@@ -67,6 +65,7 @@
 using namespace mozilla;
 
 PRLogModuleInfo* gWindowLog = nsnull;
+PRBool gInited = PR_FALSE;
 
 NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
 
@@ -172,12 +171,10 @@ nsWindow::Create(nsIWidget *aParent,
 
     // for toplevel windows, bounds are fixed to full screen size
     if (parent == nsnull) {
-        gfxIntSize bounds = nsScreenManager::GetBounds();
-
         mBounds.x = 0;
         mBounds.y = 0;
-        mBounds.width = bounds.width;
-        mBounds.height = bounds.height;
+        mBounds.width = nsAppShell::gAppShell->mScreenBounds.width;
+        mBounds.height = nsAppShell::gAppShell->mScreenBounds.height;
     }
 
     BaseCreate(nsnull, mBounds, aHandleEventFunction, aContext,
@@ -298,9 +295,8 @@ nsWindow::Show(PRBool aState)
             if (mIsVisible) {
                 // It just became visible, so send a resize update if necessary
                 // and bring it to the front.
-                gfxIntSize bounds = nsScreenManager::GetBounds();
-
-                Resize(0, 0, bounds.width, bounds.height, PR_FALSE);
+                Resize(0, 0, nsAppShell::gAppShell->mScreenBounds.width,
+                       nsAppShell::gAppShell->mScreenBounds.height, PR_FALSE);
                 BringToFront();
             }
         } else if (FindTopLevel() == TopWindow()) {
@@ -382,17 +378,16 @@ nsWindow::Resize(PRInt32 aX,
            ("Window 0x%08x Resize [% 3d,% 3d % 3dx% 3d] (repaint %d)",
             (void*)this, aX, aY, aWidth, aHeight, aRepaint));
 
-    PRBool needSizeDispatch = aWidth != mBounds.width || aHeight != mBounds.height;
-
     if (IsTopLevel()) {
         PR_LOG(gWindowLog, PR_LOG_DEBUG, ("... ignoring Resize sizes on toplevel window"));
-        gfxIntSize bounds = nsScreenManager::GetBounds();
         aX = 0;
         aY = 0;
-        aWidth = bounds.width;
-        aHeight = bounds.height;
+        aWidth = nsAppShell::gAppShell->mScreenBounds.width;
+        aHeight = nsAppShell::gAppShell->mScreenBounds.height;
     }
 
+    PRBool needSizeDispatch = aWidth != mBounds.width || aHeight != mBounds.height;
+
     mBounds.x = aX;
     mBounds.y = aY;
     mBounds.width = aWidth;
@@ -604,6 +599,7 @@ nsWindow::OnGlobalSDLEvent(SDL_Event *sd
             break;
         }
     case SDL_USEREVENT:
+    case SDL_VIDEORESIZE:
     case SDL_MOUSEBUTTONDOWN:
     case SDL_MOUSEBUTTONUP:
     case SDL_MOUSEMOTION:
@@ -616,6 +612,11 @@ nsWindow::OnGlobalSDLEvent(SDL_Event *sd
 void
 nsWindow::OnSDLEvent(SDL_Event *sdlevt) {
     switch (sdlevt->type) {
+    case SDL_VIDEORESIZE:
+        gInited = PR_FALSE;
+        Resize(sdlevt->resize.w, sdlevt->resize.h, PR_FALSE);
+        Redraw();
+        break;
     case SDL_USEREVENT:
         switch (sdlevt->user.code) {
         case WEBOS_EVENT_REDRAW:
@@ -650,22 +651,22 @@ nsWindow::InitKeyEvent(nsKeyEvent& event
     event.time = PR_Now() / 1000;
 
     switch (keysym.sym) {
+    case PDLK_GESTURE_BACK:
+    case PDLK_GESTURE_FORWARD:
+        break;
     case SDLK_BACKSPACE:
         event.keyCode = NS_VK_BACK;
-        return;
+        break;
     case SDLK_TAB:
         event.keyCode = NS_VK_TAB;
-        return;
+        break;
     case SDLK_CLEAR:
-        return;
+        break;
     case SDLK_RETURN:
         event.keyCode = NS_VK_RETURN;
-        return;
+        break;
     case SDLK_PAUSE:
-        return;
-    case SDLK_ESCAPE:
-        event.keyCode = NS_VK_ESCAPE;
-        return;
+        break;
     case SDLK_SPACE:
         event.keyCode = NS_VK_SPACE;
         break;
@@ -776,7 +777,7 @@ nsWindow::InitKeyEvent(nsKeyEvent& event
         event.keyCode = keysym.sym - SDLK_a + NS_VK_A;
         break;
     case SDLK_DELETE:
-        return;
+        break;
     case SDLK_KP0:
     case SDLK_KP1:
     case SDLK_KP2:
@@ -880,7 +881,7 @@ void
 nsWindow::DrawTo(gfxASurface *targetSurface)
 {
     if (!mIsVisible) {
-        PR_LOG(gWindowLog, PR_LOG_WARNING, ("Window 0x%08x is invisible", (void*)this));
+        PR_LOG(gWindowLog, PR_LOG_WARNING, ("Not drawing invisible child window 0x%08x", (void*)this));
         return;
     }
 
@@ -935,16 +936,34 @@ nsWindow::Redraw()
 
     PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x Redraw", (void*)this));
 
+    SDL_Surface *surface;
     nsRefPtr<gfxImageSurface> targetSurface;
+    gfxIntSize size(mBounds.width, mBounds.height);
 
-    gfxIntSize size(mBounds.width, mBounds.height);
+    if (!gInited) {
+        gInited = PR_TRUE;
+        PR_LOG(gWindowLog, PR_LOG_DEBUG, ("SDL Video Init"));
 #ifdef USE_GL
-    targetSurface = new gfxImageSurface(size, gfxASurface::ImageFormatARGB32);
+        surface = SDL_SetVideoMode(nsAppShell::gAppShell->mScreenBounds.width,
+                                   nsAppShell::gAppShell->mScreenBounds.height,
+                                   0, SDL_OPENGL);
 #else
-    SDL_Surface *surface = SDL_GetVideoSurface();
-    if (!surface) {
-        PR_LOG(gWindowLog, PR_LOG_ERROR, ("Window 0x%08x Failed to get video surface", (void*)this));
-        return;
+        surface = SDL_SetVideoMode(nsAppShell::gAppShell->mScreenBounds.width,
+                                   nsAppShell::gAppShell->mScreenBounds.height,
+                                   0, 0);
+#endif
+        if (!surface) {
+            PR_LOG(gWindowLog, PR_LOG_ERROR, ("Could not get an SDL surface: %s", SDL_GetError()));
+        }
+        NS_ABORT_IF_FALSE(surface, "Could not get an SDL surface");
+    }
+#ifndef USE_GL
+    else {
+        surface = SDL_GetVideoSurface();
+        if (!surface) {
+            PR_LOG(gWindowLog, PR_LOG_ERROR, ("Window 0x%08x Failed to get video surface", (void*)this));
+            return;
+        }
     }
 
     gfxASurface::gfxImageFormat format;
@@ -967,6 +986,8 @@ nsWindow::Redraw()
     }
 
     targetSurface = new gfxImageSurface((unsigned char*)surface->pixels, size, surface->pitch, format);
+#else
+    targetSurface = new gfxImageSurface(size, gfxASurface::ImageFormatARGB32);
 #endif
 
     DrawTo(targetSurface);
