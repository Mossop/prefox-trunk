# HG changeset patch
# User Dave Townsend <dtownsend@oxymoronical.com>
# Date 1283228666 25200
# Node ID 5ab7ee57ac5501afbbadb071d2d05c21d8570836
# Parent c7b27ba64f9de76c4c55a52824ecc9bbf424d7d3
[palm] Add Web OS widget implementation
* * *
[palm] Add base for accelerometer support
* * *
[palm] Switch to PR logging throughout
* * *
[palm] Use SDL 2D rendering surface
* * *
[palm] Better event handling and device setup
* * *
[palm] Add an idle service
* * *
[palm] Make the app shell the manager for the widget info and support rotating based on orientation
* * *
[palm] Support special keys
* * *
[palm] Better event coalescing
* * *
[palm] Add double click detection
* * *
[palm] support forward and back gestures
* * *
[palm] add layers support

diff --git a/dom/system/Makefile.in b/dom/system/Makefile.in
--- a/dom/system/Makefile.in
+++ b/dom/system/Makefile.in
@@ -61,6 +61,10 @@ ifneq (,$(filter android,$(MOZ_WIDGET_TO
 DIRS = android
 endif
 
+ifneq (,$(filter webos,$(MOZ_WIDGET_TOOLKIT)))
+DIRS = webos
+endif
+
 CPPSRCS     = \
     nsAccelerometer.cpp \
     $(NULL)
diff --git a/dom/system/webos/Makefile.in b/dom/system/webos/Makefile.in
new file mode 100644
--- /dev/null
+++ b/dom/system/webos/Makefile.in
@@ -0,0 +1,59 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org build system.
+#
+# The Initial Developer of the Original Code is Mozilla Foundation
+# Portions created by the Initial Developer are Copyright (C) 2010
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Mike Kristoffersen <mikek@mikek.dk>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH       = ../../..
+topsrcdir   = @top_srcdir@
+srcdir      = @srcdir@
+VPATH       = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE      = dom
+LIBRARY_NAME    = domsystemwebos_s
+
+# we don't want the shared lib, but we want to force the creation of a static lib.
+LIBXUL_LIBRARY   = 1
+FORCE_STATIC_LIB = 1
+EXPORT_LIBRARY = 1
+
+include $(topsrcdir)/config/config.mk
+
+CPPSRCS     = \
+        nsAccelerometerSystem.cpp \
+        $(NULL)
+
+include $(topsrcdir)/config/rules.mk
+
diff --git a/dom/system/webos/nsAccelerometerSystem.cpp b/dom/system/webos/nsAccelerometerSystem.cpp
new file mode 100644
--- /dev/null
+++ b/dom/system/webos/nsAccelerometerSystem.cpp
@@ -0,0 +1,58 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Dave Townsend <dtownsend@oxymoronical.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsAccelerometerSystem.h"
+
+using namespace mozilla;
+
+extern nsAccelerometerSystem *gAccel;
+
+nsAccelerometerSystem::nsAccelerometerSystem()
+{
+    gAccel = this;
+}
+
+nsAccelerometerSystem::~nsAccelerometerSystem()
+{
+}
+
+void nsAccelerometerSystem::Startup()
+{
+}
+
+void nsAccelerometerSystem::Shutdown()
+{
+}
diff --git a/dom/system/webos/nsAccelerometerSystem.h b/dom/system/webos/nsAccelerometerSystem.h
new file mode 100644
--- /dev/null
+++ b/dom/system/webos/nsAccelerometerSystem.h
@@ -0,0 +1,54 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Dave Townsend <dtownsend@oxymoronical.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsAccelerometerSystem_h
+#define nsAccelerometerSystem_h
+
+#include "nsAccelerometer.h"
+
+class nsAccelerometerSystem : public nsAccelerometer
+{
+public:
+  nsAccelerometerSystem();
+  virtual ~nsAccelerometerSystem();
+
+private:
+  virtual void Startup();
+  virtual void Shutdown();
+};
+
+#endif /* nsAccelerometerSystem_h */
+
diff --git a/layout/build/Makefile.in b/layout/build/Makefile.in
--- a/layout/build/Makefile.in
+++ b/layout/build/Makefile.in
@@ -147,6 +147,13 @@ SHARED_LIBRARY_LIBS += \
 LOCAL_INCLUDES	+= \
 	-I$(topsrcdir)/dom/system/android \
 	$(NULL)
+else ifneq (,$(filter webos,$(MOZ_WIDGET_TOOLKIT)))
+SHARED_LIBRARY_LIBS += \
+	$(DEPTH)/dom/system/webos/$(LIB_PREFIX)domsystemwebos_s.$(LIB_SUFFIX) \
+ 	$(NULL)
+LOCAL_INCLUDES	+= \
+	-I$(topsrcdir)/dom/system/webos \
+	$(NULL)
 endif
 
 ifdef MOZ_VORBIS
diff --git a/nsprpub/configure b/nsprpub/configure
--- a/nsprpub/configure
+++ b/nsprpub/configure
@@ -21,6 +21,12 @@ ac_help="$ac_help
   --with-android-platform=DIR
                            location of platform dir, default NDK/build/platforms/android-5/arch-arm"
 ac_help="$ac_help
+  --with-palm-pdk=DIR
+           location where the Palm PDK can be found"
+ac_help="$ac_help
+  --with-palm-toolchain=DIR
+           location of the palm toolchain, default PDK/arm-gcc"
+ac_help="$ac_help
   --with-dist-prefix=DIST_PREFIX
                           place build files in DIST_PREFIX [dist]"
 ac_help="$ac_help
@@ -648,7 +654,7 @@ else { echo "configure: error: can not r
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:652: checking host system type" >&5
+echo "configure:658: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
@@ -669,7 +675,7 @@ host_os=`echo $host | sed 's/^\([^-]*\)-
 echo "$ac_t""$host" 1>&6
 
 echo $ac_n "checking target system type""... $ac_c" 1>&6
-echo "configure:673: checking target system type" >&5
+echo "configure:679: checking target system type" >&5
 
 target_alias=$target
 case "$target_alias" in
@@ -687,7 +693,7 @@ target_os=`echo $target | sed 's/^\([^-]
 echo "$ac_t""$target" 1>&6
 
 echo $ac_n "checking build system type""... $ac_c" 1>&6
-echo "configure:691: checking build system type" >&5
+echo "configure:697: checking build system type" >&5
 
 build_alias=$build
 case "$build_alias" in
@@ -764,7 +770,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:768: checking for $ac_word" >&5
+echo "configure:774: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -887,6 +893,68 @@ EOF
 
 fi
 
+
+# Check whether --with-palm-pdk or --without-palm-pdk was given.
+if test "${with_palm_pdk+set}" = set; then
+  withval="$with_palm_pdk"
+  palm_pdk=$withval
+fi
+
+
+# Check whether --with-palm-toolchain or --without-palm-toolchain was given.
+if test "${with_palm_toolchain+set}" = set; then
+  withval="$with_palm_toolchain"
+  palm_toolchain=$withval
+fi
+
+
+if test "$target" = "arm-palm-eabi" ; then
+    if test -z "$palm_pdk" ; then
+       { echo "configure: error: Palm target, but missing --with-palm-pdk option!" 1>&2; exit 1; }
+    fi
+
+    if test -z "$palm_toolchain" ; then
+       palm_toolchain="$palm_pdk/arm-gcc"
+    fi
+
+        AS="$palm_toolchain/bin/arm-none-linux-gnueabi-as"
+    CC="$palm_toolchain/bin/arm-none-linux-gnueabi-gcc"
+    CXX="$palm_toolchain/bin/arm-none-linux-gnueabi-g++"
+    CPP="$palm_toolchain/bin/arm-none-linux-gnueabi-cpp"
+    LD="$palm_toolchain/bin/arm-none-linux-gnueabi-ld"
+    AR="$palm_toolchain/bin/arm-none-linux-gnueabi-ar"
+    RANLIB="$palm_toolchain/bin/arm-none-linux-gnueabi-ranlib"
+    STRIP="$palm_toolchain/bin/arm-none-linux-gnueabi-strip"
+
+        palm_flags="-I$palm_pdk/include -mfloat-abi=softfp -fno-short-enums -fno-exceptions"
+    palm_flags+=" -mcpu=cortex-a8 -mfpu=neon"
+    #palm_flags+=" -mcpu=arm1136jf-s -mfpu=vfp"
+    CPPFLAGS="$palm_flags $CPPFLAGS"
+    CFLAGS="$palm_flags $CFLAGS"
+    CXXFLAGS="$palm_flags $CXXFLAGS"
+    LDFLAGS="-L$palm_pdk/device/lib -Wl,--allow-shlib-undefined $LDFLAGS"
+    case "$host" in
+    *-cygwin*|*-mingw*|*-msvc*|*-mks*)
+        ;;
+    *)
+        LDFLAGS+=" --sysroot=$palm_toolchain/sysroot"
+        ;;
+    esac
+
+        if test -z "$HOST_CPPFLAGS"; then
+        HOST_CPPFLAGS=" "
+    fi
+    if test -z "$HOST_CFLAGS"; then
+        HOST_CFLAGS=" "
+    fi
+    if test -z "$HOST_CXXFLAGS"; then
+        HOST_CXXFLAGS=" "
+    fi
+    if test -z "$HOST_LDFLAGS"; then
+        HOST_LDFLAGS=" "
+    fi
+fi
+
 dist_prefix='${MOD_DEPTH}/dist'
 dist_bindir='${dist_prefix}/bin'
 dist_includedir='${dist_prefix}/include/nspr'
@@ -1179,7 +1247,7 @@ if test -z "$SKIP_PATH_CHECKS"; then
     # Extract the first word of "$WHOAMI whoami", so it can be a program name with args.
 set dummy $WHOAMI whoami; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1183: checking for $ac_word" >&5
+echo "configure:1251: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_WHOAMI'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1250,13 +1318,13 @@ if test "$target" != "$host"; then
     _SAVE_LDFLAGS="$LDFLAGS"
 
     echo $ac_n "checking for $host compiler""... $ac_c" 1>&6
-echo "configure:1254: checking for $host compiler" >&5
+echo "configure:1322: checking for $host compiler" >&5
     for ac_prog in $HOST_CC gcc cc /usr/ucb/cc
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1260: checking for $ac_word" >&5
+echo "configure:1328: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_HOST_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1301,26 +1369,10 @@ test -n "$HOST_CC" || HOST_CC=""""
     CFLAGS="$HOST_CFLAGS"
     LDFLAGS="$HOST_LDFLAGS"
 
-    echo $ac_n "checking whether the $host compiler ($HOST_CC $HOST_CFLAGS $HOST_LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1306: checking whether the $host compiler ($HOST_CC $HOST_CFLAGS $HOST_LDFLAGS) works" >&5
-    cat > conftest.$ac_ext <<EOF
-#line 1308 "configure"
-#include "confdefs.h"
-
-int main() {
-return(0);
-; return 0; }
-EOF
-if { (eval echo configure:1315: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
-  rm -rf conftest*
-  ac_cv_prog_host_cc_works=1 echo "$ac_t""yes" 1>&6
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  { echo "configure: error: installation or configuration problem: $host compiler $HOST_CC cannot create executables." 1>&2; exit 1; } 
-fi
-rm -f conftest*
+#    AC_MSG_CHECKING([whether the $host compiler ($HOST_CC $HOST_CFLAGS $HOST_LDFLAGS) works])
+#    AC_TRY_COMPILE([], [return(0);], 
+#        [ac_cv_prog_host_cc_works=1 AC_MSG_RESULT([yes])],
+#        AC_MSG_ERROR([installation or configuration problem: $host compiler $HOST_CC cannot create executables.]) )
 
     CC=$_SAVE_CC
     CFLAGS=$_SAVE_CFLAGS
@@ -1340,7 +1392,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1344: checking for $ac_word" >&5
+echo "configure:1396: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1374,7 +1426,7 @@ test -n "$CC" || CC="echo"
     # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1378: checking for $ac_word" >&5
+echo "configure:1430: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1404,7 +1456,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1408: checking for $ac_word" >&5
+echo "configure:1460: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1455,7 +1507,7 @@ fi
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1459: checking for $ac_word" >&5
+echo "configure:1511: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1487,7 +1539,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1491: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:1543: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -1498,12 +1550,12 @@ cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1502 "configure"
+#line 1554 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:1507: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1559: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -1529,12 +1581,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1533: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1585: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:1538: checking whether we are using GNU C" >&5
+echo "configure:1590: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1543,7 +1595,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1547: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1599: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -1562,7 +1614,7 @@ ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:1566: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:1618: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1599,7 +1651,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1603: checking for $ac_word" >&5
+echo "configure:1655: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1635,7 +1687,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1639: checking for $ac_word" >&5
+echo "configure:1691: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1667,7 +1719,7 @@ test -n "$CXX" || CXX="gcc"
 
 
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1671: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
+echo "configure:1723: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
 
 ac_ext=C
 # CXXFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -1678,12 +1730,12 @@ cross_compiling=$ac_cv_prog_cxx_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1682 "configure"
+#line 1734 "configure"
 #include "confdefs.h"
 
 int main(){return(0);}
 EOF
-if { (eval echo configure:1687: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1739: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cxx_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -1709,12 +1761,12 @@ if test $ac_cv_prog_cxx_works = no; then
   { echo "configure: error: installation or configuration problem: C++ compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1713: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1765: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cxx_cross" 1>&6
 cross_compiling=$ac_cv_prog_cxx_cross
 
 echo $ac_n "checking whether we are using GNU C++""... $ac_c" 1>&6
-echo "configure:1718: checking whether we are using GNU C++" >&5
+echo "configure:1770: checking whether we are using GNU C++" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gxx'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1723,7 +1775,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1727: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1779: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gxx=yes
 else
   ac_cv_prog_gxx=no
@@ -1742,7 +1794,7 @@ ac_test_CXXFLAGS="${CXXFLAGS+set}"
 ac_save_CXXFLAGS="$CXXFLAGS"
 CXXFLAGS=
 echo $ac_n "checking whether ${CXX-g++} accepts -g""... $ac_c" 1>&6
-echo "configure:1746: checking whether ${CXX-g++} accepts -g" >&5
+echo "configure:1798: checking whether ${CXX-g++} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1787,7 +1839,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1791: checking for $ac_word" >&5
+echo "configure:1843: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1822,7 +1874,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1826: checking for $ac_word" >&5
+echo "configure:1878: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1857,7 +1909,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1861: checking for $ac_word" >&5
+echo "configure:1913: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AS'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1892,7 +1944,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1896: checking for $ac_word" >&5
+echo "configure:1948: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1927,7 +1979,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1931: checking for $ac_word" >&5
+echo "configure:1983: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_STRIP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1962,7 +2014,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1966: checking for $ac_word" >&5
+echo "configure:2018: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1997,7 +2049,7 @@ else
     # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2001: checking for $ac_word" >&5
+echo "configure:2053: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2027,7 +2079,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2031: checking for $ac_word" >&5
+echo "configure:2083: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2078,7 +2130,7 @@ fi
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2082: checking for $ac_word" >&5
+echo "configure:2134: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2110,7 +2162,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:2114: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:2166: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -2121,12 +2173,12 @@ cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 2125 "configure"
+#line 2177 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:2130: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2182: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -2152,12 +2204,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:2156: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:2208: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:2161: checking whether we are using GNU C" >&5
+echo "configure:2213: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2166,7 +2218,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2170: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2222: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -2185,7 +2237,7 @@ ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:2189: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:2241: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2225,7 +2277,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2229: checking for $ac_word" >&5
+echo "configure:2281: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2257,7 +2309,7 @@ test -n "$CXX" || CXX="gcc"
 
 
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:2261: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
+echo "configure:2313: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
 
 ac_ext=C
 # CXXFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -2268,12 +2320,12 @@ cross_compiling=$ac_cv_prog_cxx_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 2272 "configure"
+#line 2324 "configure"
 #include "confdefs.h"
 
 int main(){return(0);}
 EOF
-if { (eval echo configure:2277: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2329: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cxx_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -2299,12 +2351,12 @@ if test $ac_cv_prog_cxx_works = no; then
   { echo "configure: error: installation or configuration problem: C++ compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:2303: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:2355: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cxx_cross" 1>&6
 cross_compiling=$ac_cv_prog_cxx_cross
 
 echo $ac_n "checking whether we are using GNU C++""... $ac_c" 1>&6
-echo "configure:2308: checking whether we are using GNU C++" >&5
+echo "configure:2360: checking whether we are using GNU C++" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gxx'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2313,7 +2365,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:2317: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:2369: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gxx=yes
 else
   ac_cv_prog_gxx=no
@@ -2332,7 +2384,7 @@ ac_test_CXXFLAGS="${CXXFLAGS+set}"
 ac_save_CXXFLAGS="$CXXFLAGS"
 CXXFLAGS=
 echo $ac_n "checking whether ${CXX-g++} accepts -g""... $ac_c" 1>&6
-echo "configure:2336: checking whether ${CXX-g++} accepts -g" >&5
+echo "configure:2388: checking whether ${CXX-g++} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2366,7 +2418,7 @@ fi
         fi
     fi
     echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:2370: checking how to run the C preprocessor" >&5
+echo "configure:2422: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -2381,13 +2433,13 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 2385 "configure"
+#line 2437 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2391: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2443: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2398,13 +2450,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 2402 "configure"
+#line 2454 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2408: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2460: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2415,13 +2467,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 2419 "configure"
+#line 2471 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2425: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2477: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2448,7 +2500,7 @@ echo "$ac_t""$CPP" 1>&6
     # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2452: checking for $ac_word" >&5
+echo "configure:2504: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2480,7 +2532,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2484: checking for $ac_word" >&5
+echo "configure:2536: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AS'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2521,7 +2573,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2525: checking for $ac_word" >&5
+echo "configure:2577: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2562,7 +2614,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2566: checking for $ac_word" >&5
+echo "configure:2618: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2603,7 +2655,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2607: checking for $ac_word" >&5
+echo "configure:2659: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_STRIP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2644,7 +2696,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2648: checking for $ac_word" >&5
+echo "configure:2700: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_WINDRES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2712,7 +2764,7 @@ else
 fi
 
 echo $ac_n "checking for gcc -pipe support""... $ac_c" 1>&6
-echo "configure:2716: checking for gcc -pipe support" >&5
+echo "configure:2768: checking for gcc -pipe support" >&5
 if test -n "$GNU_CC" && test -n "$GNU_CXX" && test -n "$GNU_AS"; then
     echo '#include <stdio.h>' > dummy-hello.c
     echo 'int main() { printf("Hello World\n"); return 0; }' >> dummy-hello.c
@@ -2727,14 +2779,14 @@ if test -n "$GNU_CC" && test -n "$GNU_CX
         _SAVE_CFLAGS=$CFLAGS
         CFLAGS="$CFLAGS -pipe"
         cat > conftest.$ac_ext <<EOF
-#line 2731 "configure"
+#line 2783 "configure"
 #include "confdefs.h"
  #include <stdio.h> 
 int main() {
 printf("Hello World\n");
 ; return 0; }
 EOF
-if { (eval echo configure:2738: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2790: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   _res_gcc_pipe="yes"
 else
@@ -2764,16 +2816,16 @@ _SAVE_CFLAGS="$CFLAGS"
 CFLAGS="$CFLAGS -fprofile-generate -fprofile-correction"
 
 echo $ac_n "checking whether C compiler supports -fprofile-generate""... $ac_c" 1>&6
-echo "configure:2768: checking whether C compiler supports -fprofile-generate" >&5
+echo "configure:2820: checking whether C compiler supports -fprofile-generate" >&5
 cat > conftest.$ac_ext <<EOF
-#line 2770 "configure"
+#line 2822 "configure"
 #include "confdefs.h"
 
 int main() {
 return 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2777: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2829: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
    PROFILE_GEN_CFLAGS="-fprofile-generate"
                  result="yes" 
@@ -2796,7 +2848,7 @@ CFLAGS="$_SAVE_CFLAGS"
 
 if test "$GNU_CC"; then
     echo $ac_n "checking for visibility(hidden) attribute""... $ac_c" 1>&6
-echo "configure:2800: checking for visibility(hidden) attribute" >&5
+echo "configure:2852: checking for visibility(hidden) attribute" >&5
 if eval "test \"`echo '$''{'ac_cv_visibility_hidden'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2820,7 +2872,7 @@ echo "$ac_t""$ac_cv_visibility_hidden" 1
 EOF
 
         echo $ac_n "checking for visibility pragma support""... $ac_c" 1>&6
-echo "configure:2824: checking for visibility pragma support" >&5
+echo "configure:2876: checking for visibility pragma support" >&5
 if eval "test \"`echo '$''{'ac_cv_visibility_pragma'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2873,7 +2925,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2877: checking for $ac_word" >&5
+echo "configure:2929: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3149,17 +3201,17 @@ EOF
     DSO_LDOPTS='-brtl -bnortllib -bM:SRE -bnoentry -bexpall -blibpath:/usr/lib:/lib'
     ac_safe=`echo "sys/atomic_op.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for sys/atomic_op.h""... $ac_c" 1>&6
-echo "configure:3153: checking for sys/atomic_op.h" >&5
+echo "configure:3205: checking for sys/atomic_op.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3158 "configure"
+#line 3210 "configure"
 #include "confdefs.h"
 #include <sys/atomic_op.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3163: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3215: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3316,7 +3368,7 @@ EOF
         _DEBUG_FLAGS='-gdwarf-2 -O0'
         MKSHLIB='$(CCC) $(DSO_LDOPTS) -o $@'
         echo $ac_n "checking for gethostbyaddr in -lbind""... $ac_c" 1>&6
-echo "configure:3320: checking for gethostbyaddr in -lbind" >&5
+echo "configure:3372: checking for gethostbyaddr in -lbind" >&5
 ac_lib_var=`echo bind'_'gethostbyaddr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3324,7 +3376,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3328 "configure"
+#line 3380 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3335,7 +3387,7 @@ int main() {
 gethostbyaddr()
 ; return 0; }
 EOF
-if { (eval echo configure:3339: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3391: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4082,6 +4134,45 @@ EOF
     OS_TARGET=Android
     ;;
 
+arm-palm-eabi)
+    if test -z "$USE_NSPR_THREADS"; then
+        USE_PTHREADS=1
+        IMPL_STRATEGY=_PTH
+    fi
+    cat >> confdefs.h <<\EOF
+#define XP_UNIX 1
+EOF
+
+    cat >> confdefs.h <<\EOF
+#define _GNU_SOURCE 1
+EOF
+
+    cat >> confdefs.h <<\EOF
+#define HAVE_FCNTL_FILE_LOCKING 1
+EOF
+
+    cat >> confdefs.h <<\EOF
+#define LINUX 1
+EOF
+
+    CFLAGS="$CFLAGS -Wall"
+    CXXFLAGS="$CXXFLAGS -Wall"
+    MDCPUCFG_H=_linux.cfg
+    PR_MD_CSRCS=linux.c
+    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
+    DSO_CFLAGS=-fPIC
+    DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'
+    _OPTIMIZE_FLAGS=-O2
+    _DEBUG_FLAGS="-g -fno-inline"  # most people on linux use gcc/gdb, and that
+                                   # combo is not yet good at debugging inlined
+                                   # functions (even when using DWARF2 as the
+                                   # debugging format)
+    COMPILER_TAG=_glibc
+    CPU_ARCH=arm
+    CPU_ARCH_TAG=_arm
+    OS_TARGET=WebOS
+    ;;
+
 *-linux*|*-gnu*|*-k*bsd*-gnu)
     if test -z "$USE_NSPR_THREADS"; then
         USE_PTHREADS=1
@@ -4710,17 +4801,17 @@ EOF
         _OPTIMIZE_FLAGS="$_OPTIMIZE_FLAGS -Olimit 4000"
         ac_safe=`echo "machine/builtins.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for machine/builtins.h""... $ac_c" 1>&6
-echo "configure:4714: checking for machine/builtins.h" >&5
+echo "configure:4805: checking for machine/builtins.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4719 "configure"
+#line 4810 "configure"
 #include "confdefs.h"
 #include <machine/builtins.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4724: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4815: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -5369,7 +5460,7 @@ case $target in
     ;;
 *)
     echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:5373: checking for dlopen in -ldl" >&5
+echo "configure:5464: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -5377,7 +5468,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 5381 "configure"
+#line 5472 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -5388,7 +5479,7 @@ int main() {
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:5392: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5483: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -5405,17 +5496,17 @@ if eval "test \"`echo '$ac_cv_lib_'$ac_l
   echo "$ac_t""yes" 1>&6
   ac_safe=`echo "dlfcn.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for dlfcn.h""... $ac_c" 1>&6
-echo "configure:5409: checking for dlfcn.h" >&5
+echo "configure:5500: checking for dlfcn.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5414 "configure"
+#line 5505 "configure"
 #include "confdefs.h"
 #include <dlfcn.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:5419: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:5510: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -5448,13 +5539,13 @@ esac
 
 if test $ac_cv_prog_gcc = yes; then
     echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
-echo "configure:5452: checking whether ${CC-cc} needs -traditional" >&5
+echo "configure:5543: checking whether ${CC-cc} needs -traditional" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
     ac_pattern="Autoconf.*'x'"
   cat > conftest.$ac_ext <<EOF
-#line 5458 "configure"
+#line 5549 "configure"
 #include "confdefs.h"
 #include <sgtty.h>
 Autoconf TIOCGETP
@@ -5472,7 +5563,7 @@ rm -f conftest*
 
   if test $ac_cv_prog_gcc_traditional = no; then
     cat > conftest.$ac_ext <<EOF
-#line 5476 "configure"
+#line 5567 "configure"
 #include "confdefs.h"
 #include <termio.h>
 Autoconf TCGETA
@@ -5496,12 +5587,12 @@ fi
 for ac_func in lchown strerror
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:5500: checking for $ac_func" >&5
+echo "configure:5591: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5505 "configure"
+#line 5596 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -5524,7 +5615,7 @@ choke me
 
 ; return 0; }
 EOF
-if { (eval echo configure:5528: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5619: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -5565,7 +5656,7 @@ hpux*)
 if test -z "$GNU_CC"; then
 
     echo $ac_n "checking for +Olit support""... $ac_c" 1>&6
-echo "configure:5569: checking for +Olit support" >&5
+echo "configure:5660: checking for +Olit support" >&5
 if eval "test \"`echo '$''{'ac_cv_hpux_usable_olit_option'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5607,7 +5698,7 @@ wince*)
 *)
     
 echo $ac_n "checking for pthread_create in -lpthreads""... $ac_c" 1>&6
-echo "configure:5611: checking for pthread_create in -lpthreads" >&5
+echo "configure:5702: checking for pthread_create in -lpthreads" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { return v; } 
@@ -5629,7 +5720,7 @@ echo "
         echo "$ac_t""no" 1>&6
         
 echo $ac_n "checking for pthread_create in -lpthread""... $ac_c" 1>&6
-echo "configure:5633: checking for pthread_create in -lpthread" >&5
+echo "configure:5724: checking for pthread_create in -lpthread" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { return v; } 
@@ -5651,7 +5742,7 @@ echo "
         echo "$ac_t""no" 1>&6
         
 echo $ac_n "checking for pthread_create in -lc_r""... $ac_c" 1>&6
-echo "configure:5655: checking for pthread_create in -lc_r" >&5
+echo "configure:5746: checking for pthread_create in -lc_r" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { return v; } 
@@ -5673,7 +5764,7 @@ echo "
         echo "$ac_t""no" 1>&6
         
 echo $ac_n "checking for pthread_create in -lc""... $ac_c" 1>&6
-echo "configure:5677: checking for pthread_create in -lc" >&5
+echo "configure:5768: checking for pthread_create in -lc" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { return v; } 
@@ -5805,7 +5896,7 @@ if test -n "$USE_PTHREADS"; then
       rm -f conftest*
    ac_cv_have_dash_pthread=no
    echo $ac_n "checking whether ${CC-cc} accepts -pthread""... $ac_c" 1>&6
-echo "configure:5809: checking whether ${CC-cc} accepts -pthread" >&5
+echo "configure:5900: checking whether ${CC-cc} accepts -pthread" >&5
    echo 'int main() { return 0; }' | cat > conftest.c
    ${CC-cc} -pthread -o conftest conftest.c > conftest.out 2>&1
    if test $? -eq 0; then
@@ -5828,7 +5919,7 @@ echo "configure:5809: checking whether $
 			    ac_cv_have_dash_pthreads=no
     if test "$ac_cv_have_dash_pthread" = "no"; then
 	    echo $ac_n "checking whether ${CC-cc} accepts -pthreads""... $ac_c" 1>&6
-echo "configure:5832: checking whether ${CC-cc} accepts -pthreads" >&5
+echo "configure:5923: checking whether ${CC-cc} accepts -pthreads" >&5
     	echo 'int main() { return 0; }' | cat > conftest.c
 	    ${CC-cc} -pthreads -o conftest conftest.c > conftest.out 2>&1
     	if test $? -eq 0; then
diff --git a/toolkit/library/libxul-config.mk b/toolkit/library/libxul-config.mk
--- a/toolkit/library/libxul-config.mk
+++ b/toolkit/library/libxul-config.mk
@@ -304,6 +304,10 @@ ifeq ($(MOZ_WIDGET_TOOLKIT),android)
 COMPONENT_LIBS += widget_android
 endif
 
+ifeq ($(MOZ_WIDGET_TOOLKIT),webos)
+COMPONENT_LIBS += widget_webos
+endif
+
 STATIC_LIBS += thebes ycbcr
 
 ifneq ($(OS_ARCH)_$(OS_TEST),Linux_x86_64)
@@ -391,6 +395,10 @@ ifdef HAVE_CLOCK_MONOTONIC
 EXTRA_DSO_LDOPTS += $(REALTIME_LIBS)
 endif
 
+ifdef WEBOS
+OS_LIBS += -lGLESv2 -lSDL -lpdl -lSDL_image
+endif
+
 ifeq (android,$(MOZ_WIDGET_TOOLKIT))
 OS_LIBS += -lGLESv2
 endif
diff --git a/toolkit/library/nsStaticXULComponents.cpp b/toolkit/library/nsStaticXULComponents.cpp
--- a/toolkit/library/nsStaticXULComponents.cpp
+++ b/toolkit/library/nsStaticXULComponents.cpp
@@ -81,6 +81,8 @@
 #  define WIDGET_MODULES MODULE(nsWidgetQtModule)
 #elif defined(MOZ_WIDGET_ANDROID)
 #  define WIDGET_MODULES MODULE(nsWidgetAndroidModule)
+#elif defined(MOZ_WIDGET_WEBOS)
+#  define WIDGET_MODULES MODULE(nsWidgetWebOSModule)
 #else
 #  error Unknown widget module.
 #endif
diff --git a/widget/src/Makefile.in b/widget/src/Makefile.in
--- a/widget/src/Makefile.in
+++ b/widget/src/Makefile.in
@@ -46,7 +46,7 @@ MODULE  = widget
 
 DIRS		= shared xpwidgets
 
-ifneq (,$(filter beos os2 cocoa qt android,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter beos os2 cocoa qt android webos,$(MOZ_WIDGET_TOOLKIT)))
 DIRS		+= $(MOZ_WIDGET_TOOLKIT)
 endif
 
diff --git a/widget/src/webos/Makefile.in b/widget/src/webos/Makefile.in
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/Makefile.in
@@ -0,0 +1,103 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+#   Mozilla Corp
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Vladimir Vukicevic <vladimir@pobox.com>
+#   Dave Townsend <dtownsend@oxymoronical.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= widget
+LIBRARY_NAME	= widget_webos
+EXPORT_LIBRARY  = 1
+IS_COMPONENT    = 1
+MODULE_NAME	= nsWidgetWebOSModule
+GRE_MODULE	= 1
+LIBXUL_LIBRARY	= 1
+
+OS_CXXFLAGS := $(filter-out -pedantic,$(OS_CXXFLAGS))
+
+CPPSRCS	= \
+	nsWidgetFactory.cpp \
+	nsAppShell.cpp \
+	nsToolkit.cpp \
+	nsWindow.cpp \
+	nsLookAndFeel.cpp \
+	nsScreenManager.cpp \
+	nsIdleServiceWebOS.cpp \
+	$(NULL)
+
+NOT_THERE_YET_CPPSRCS = \
+	nsQtKeyUtils.cpp \
+	nsClipboard.cpp \
+	nsBidiKeyboard.cpp \
+	nsDragService.cpp \
+	nsNativeThemeQt.cpp \
+	mozqwidget.cpp \
+	nsSound.cpp \
+	nsFilePicker.cpp \
+	nsAccelerometer.cpp \
+	$(NULL)
+
+SHARED_LIBRARY_LIBS = ../xpwidgets/libxpwidgets_s.a
+
+EXTRA_DSO_LDOPTS = \
+	$(MOZ_COMPONENT_LIBS) \
+	-lgkgfx \
+	-lthebes \
+	$(MOZ_JS_LIBS) \
+	$(QCMS_LIBS) \
+	-lGLESv2 \
+	-lSDL \
+	-lpdl \
+	$(NULL)
+
+EXTRA_DSO_LDOPTS += -L$(DIST)/lib
+
+include $(topsrcdir)/config/rules.mk
+
+DEFINES		+= -D_IMPL_NS_WIDGET -DFORCE_PR_LOG
+#DEFINES		+= -DDEBUG_WIDGETS
+
+LOCAL_INCLUDES	+= \
+	-I$(topsrcdir)/widget/src/xpwidgets \
+	-I$(topsrcdir)/dom/system/webos \
+	-I$(srcdir) \
+	$(NULL)
+
diff --git a/widget/src/webos/nsAppShell.cpp b/widget/src/webos/nsAppShell.cpp
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsAppShell.cpp
@@ -0,0 +1,312 @@
+/* -*- Mode: c++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4; -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsAppShell.h"
+#include "nsWindow.h"
+#include "nsThreadUtils.h"
+#include "prlog.h"
+#include "prenv.h"
+#include "nsIAppStartup.h"
+#include "nsIObserverService.h"
+#include "mozilla/Services.h"
+
+#include "SDL_image.h"
+
+#define ORIENTATION_THRESHOLD 10000
+#define PI 3.14159265358979323846
+
+#include "nsAccelerometerSystem.h"
+
+using namespace mozilla;
+
+PRLogModuleInfo* gAppShellLog = nsnull;
+
+nsAccelerometerSystem *gAccel = nsnull;
+
+nsAppShell *nsAppShell::gAppShell = nsnull;
+
+nsAppShell::nsAppShell() :
+  mOrientation(PDL_ORIENTATION_0)
+{
+#if defined(PR_LOGGING)
+    if (!gAppShellLog) {
+        gAppShellLog = PR_NewLogModule("nsAppShell");
+    }
+#endif
+
+    PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("SDL Init"));
+    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK) < 0) {
+        NS_ABORT_IF_FALSE(PR_FALSE, "Unable to initialise SDL");
+    }
+    PDL_Init(0);
+
+    const SDL_VideoInfo *info = SDL_GetVideoInfo();
+    mScreenBounds.width = info->current_w;
+    mScreenBounds.height = info->current_h;
+    PR_LOG(gAppShellLog, PR_LOG_DEBUG,
+           ("Screen is % 3dx% 3d", mScreenBounds.width, mScreenBounds.height));
+
+    SDL_Surface *surface = SDL_SetVideoMode(mScreenBounds.width, mScreenBounds.height, 0, 0);
+
+    SDL_Surface *image = IMG_Load("splashscreen.png");
+    if (image) {
+        SDL_Rect dest = {
+            (surface->w - image->w) / 2,
+            (surface->h - image->h) / 2,
+            0, 0
+        };
+        SDL_BlitSurface(image, NULL, surface, &dest);
+        SDL_FreeSurface(image);
+        SDL_Flip(surface);
+    }
+
+    PDL_BannerMessagesEnable(PDL_TRUE);
+    PDL_ScreenTimeoutEnable(PDL_TRUE);
+    PDL_GesturesEnable(PDL_TRUE);
+
+    mScreenTransform = gfxMatrix();
+    mEventTransform = gfxMatrix();
+
+    mJoystick = SDL_JoystickOpen(0);
+    if (!mJoystick)
+        PR_LOG(gAppShellLog, PR_LOG_WARN, ("Unable to open accelerometer"));
+
+    gAppShell = this;
+}
+
+nsAppShell::~nsAppShell()
+{
+    PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Destroy"));
+
+    PDL_Quit();
+    SDL_Quit();
+
+    gAppShell = nsnull;
+}
+
+nsresult
+nsAppShell::Init()
+{
+    PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Init"));
+
+    return nsBaseAppShell::Init();
+}
+
+void
+nsAppShell::ChangeOrientation(PDL_Orientation aNewOrientation)
+{
+    /*if (aNewOrientation == PDL_ORIENTATION_270) {
+        aNewOrientation = PDL_ORIENTATION_90;
+    }
+
+    if (aNewOrientation == PDL_ORIENTATION_180) {
+        aNewOrientation = PDL_ORIENTATION_0;
+    }*/
+
+    if (mOrientation == aNewOrientation) {
+        return;
+    }
+
+    PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Changing orientation"));
+
+    PRBool wasPortrait = mOrientation == PDL_ORIENTATION_0 ||
+                         mOrientation == PDL_ORIENTATION_180;
+    PRBool isPortrait = aNewOrientation == PDL_ORIENTATION_0 ||
+                        aNewOrientation == PDL_ORIENTATION_180;
+
+    PDL_SetOrientation(aNewOrientation);
+    mOrientation = aNewOrientation;
+
+    if (wasPortrait == isPortrait) {
+        // No change to screen size, just redraw
+        ScheduleRedraw();
+    }
+    else {
+        PRInt32 temp = mScreenBounds.width;
+        mScreenBounds.width = mScreenBounds.height;
+        mScreenBounds.height = temp;
+
+        SDL_Event sdlevt;
+        sdlevt.type = SDL_VIDEORESIZE;
+        sdlevt.resize.type = SDL_VIDEORESIZE;
+        sdlevt.resize.w = mScreenBounds.width;
+        sdlevt.resize.h = mScreenBounds.height;
+        SDL_PushEvent(&sdlevt);
+    }
+
+    mScreenTransform.Reset();
+    mEventTransform.Reset();
+    switch(nsAppShell::gAppShell->mOrientation) {
+    case PDL_ORIENTATION_0:
+        break;
+    case PDL_ORIENTATION_90:
+        mScreenTransform.Translate(gfxPoint(0, mScreenBounds.width));
+        mScreenTransform.Rotate(-PI / 2);
+        mEventTransform.Translate(gfxPoint(mScreenBounds.width, 0));
+        mEventTransform.Rotate(PI / 2);
+        break;
+    case PDL_ORIENTATION_180:
+        mScreenTransform.Translate(gfxPoint(mScreenBounds.width, mScreenBounds.height));
+        mScreenTransform.Rotate(PI);
+        mEventTransform.Translate(gfxPoint(mScreenBounds.width, mScreenBounds.height));
+        mEventTransform.Rotate(PI);
+        break;
+    case PDL_ORIENTATION_270:
+        mScreenTransform.Translate(gfxPoint(mScreenBounds.height, 0));
+        mScreenTransform.Rotate(PI / 2);
+        mEventTransform.Translate(gfxPoint(0, mScreenBounds.height));
+        mEventTransform.Rotate(-PI / 2);
+        break;
+    }
+}
+
+void
+nsAppShell::CheckOrientation()
+{
+    Sint16 x = SDL_JoystickGetAxis(mJoystick, 0);
+    Sint16 y = SDL_JoystickGetAxis(mJoystick, 1);
+
+    Sint16 absx = abs(x);
+    Sint16 absy = abs(y);
+
+    if (abs(absy - absx) > ORIENTATION_THRESHOLD) {
+        if (absx > absy) {
+            ChangeOrientation(x < 0 ? PDL_ORIENTATION_270 : PDL_ORIENTATION_90);
+        }
+        else {
+            ChangeOrientation(y < 0 ? PDL_ORIENTATION_180 : PDL_ORIENTATION_0);
+        }
+    }
+}
+
+void
+nsAppShell::ScheduleNativeEventCallback()
+{
+}
+
+void
+nsAppShell::ScheduleRedraw()
+{
+    PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("ScheduleRedraw"));
+
+    SDL_Event sdlevt;
+    sdlevt.type = WEBOS_EVENT_REDRAW;
+    sdlevt.user.code = WEBOS_EVENT_REDRAW;
+    SDL_PushEvent(&sdlevt);
+}
+
+PRBool
+nsAppShell::ShouldCoalesceEvent(SDL_Event &event)
+{
+    switch (event.type) {
+    case WEBOS_EVENT_REDRAW:
+    case SDL_MOUSEMOTION:
+    case SDL_JOYAXISMOTION:
+    case SDL_VIDEORESIZE:
+        return PR_TRUE;
+    }
+
+    return PR_FALSE;
+}
+
+PRBool
+nsAppShell::CanCoalesceEvents(SDL_Event &event1, SDL_Event &event2)
+{
+    return event1.type == event2.type;
+}
+
+PRBool
+nsAppShell::ProcessNextNativeEvent(PRBool mayWait)
+{
+    //PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("ProcessNextNativeEvent(%d)", mayWait));
+
+    SDL_Event event;
+    int count = SDL_PollEvent(&event);
+
+    if (count == 0)
+        return PR_FALSE;
+
+    if (ShouldCoalesceEvent(event))
+    {
+        int coalesceCount = 0;
+
+        // Coalesce any events in the queue
+        SDL_Event pendingEvent;
+        while (true)
+        {
+            count = SDL_PeepEvents(&pendingEvent, 1, SDL_PEEKEVENT, SDL_ALLEVENTS);
+            if (count <= 0)
+                break;
+            if (!CanCoalesceEvents(event, pendingEvent))
+                break;
+            coalesceCount++;
+            SDL_PollEvent(&event);
+        }
+        //PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Coalesced %d events", coalesceCount));
+    }
+
+    switch (event.type) {
+    case SDL_JOYAXISMOTION:
+        CheckOrientation();
+        break;
+    case SDL_QUIT:
+    {
+        PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Quit requested"));
+        // Fake shutdown sequence. webOS gives us just 1 second to shutdown or
+        // the application is killed so this does the best we can in a short
+        // space of time
+        nsCOMPtr<nsIObserverService> obsServ = mozilla::services::GetObserverService();
+        NS_NAMED_LITERAL_STRING(context, "shutdown-persist");
+        obsServ->NotifyObservers(nsnull, "quit-application-granted", nsnull);
+        obsServ->NotifyObservers(nsnull, "quit-application-forced", nsnull);
+        obsServ->NotifyObservers(nsnull, "quit-application", nsnull);
+        obsServ->NotifyObservers(nsnull, "profile-change-net-teardown", context.get());
+        obsServ->NotifyObservers(nsnull, "profile-change-teardown", context.get());
+        obsServ->NotifyObservers(nsnull, "profile-before-change", context.get());
+        // Then a controlled but very quick exit.
+        PDL_Quit();
+        SDL_Quit();
+        exit(0);
+    }
+    default:
+        PR_LOG(gAppShellLog, PR_LOG_DEBUG, ("Got event type %d", event.type));
+        nsWindow::OnGlobalSDLEvent(&event);
+    }
+
+    return PR_TRUE;
+}
diff --git a/widget/src/webos/nsAppShell.h b/widget/src/webos/nsAppShell.h
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsAppShell.h
@@ -0,0 +1,79 @@
+/* -*- Mode: c++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4; -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsAppShell_h__
+#define nsAppShell_h__
+
+#include "nsBaseAppShell.h"
+#include "gfxContext.h"
+
+#include "PDL.h"
+#include "SDL.h"
+
+#define WEBOS_EVENT_REDRAW (SDL_USEREVENT + 1)
+
+class nsAppShell : public nsBaseAppShell
+{
+public:
+    static nsAppShell *gAppShell;
+
+    nsAppShell();
+
+    nsresult Init();
+    static void ScheduleRedraw();
+
+    gfxIntSize mScreenBounds;
+    gfxMatrix mScreenTransform;
+    gfxMatrix mEventTransform;
+
+protected:
+    SDL_Joystick *mJoystick;
+    PDL_Orientation mOrientation;
+
+    virtual ~nsAppShell();
+
+    void ChangeOrientation(PDL_Orientation aNewOrientation);
+    void CheckOrientation();
+    virtual void ScheduleNativeEventCallback();
+    PRBool ShouldCoalesceEvent(SDL_Event &event);
+    PRBool CanCoalesceEvents(SDL_Event &event1, SDL_Event &event2);
+    virtual PRBool ProcessNextNativeEvent(PRBool mayWait);
+};
+
+#endif // nsAppShell_h__
+
diff --git a/widget/src/webos/nsIdleServiceWebOS.cpp b/widget/src/webos/nsIdleServiceWebOS.cpp
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsIdleServiceWebOS.cpp
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Gijs Kruitbosch <gijskruitbosch@gmail.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Michael Wu <mwu@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIdleServiceWebOS.h"
+#include "nsIServiceManager.h"
+
+NS_IMPL_ISUPPORTS1(nsIdleServiceWebOS, nsIIdleService)
+
+nsIdleServiceWebOS::nsIdleServiceWebOS()
+{
+}
+
+nsIdleServiceWebOS::~nsIdleServiceWebOS()
+{
+}
+
+NS_IMETHODIMP
+nsIdleServiceWebOS::GetIdleTime(PRUint32 *aTimeDiff)
+{
+    extern PRUint32 gLastInputEventTime;
+
+    PRUint32 nowTime = PR_IntervalToMicroseconds(PR_IntervalNow());
+    *aTimeDiff = (nowTime - gLastInputEventTime) / 1000;
+    return NS_OK;
+}
+
diff --git a/widget/src/webos/nsIdleServiceWebOS.h b/widget/src/webos/nsIdleServiceWebOS.h
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsIdleServiceWebOS.h
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Gijs Kruitbosch <gijskruitbosch@gmail.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Michael Wu <mwu@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsIdleServiceWebOS_h__
+#define nsIdleServiceWebOS_h__
+
+#include "nsIdleService.h"
+
+class nsIdleServiceWebOS : public nsIdleService
+{
+public:
+    NS_DECL_ISUPPORTS
+    nsIdleServiceWebOS();
+
+    NS_IMETHOD GetIdleTime(PRUint32* idleTime);
+private:
+    ~nsIdleServiceWebOS();
+};
+
+#endif // nsIdleServiceWebOS_h__
diff --git a/widget/src/webos/nsLookAndFeel.cpp b/widget/src/webos/nsLookAndFeel.cpp
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsLookAndFeel.cpp
@@ -0,0 +1,610 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsLookAndFeel.h"
+
+nsLookAndFeel::nsLookAndFeel()
+    : nsXPLookAndFeel()
+{
+}
+
+nsLookAndFeel::~nsLookAndFeel()
+{
+}
+
+nsresult
+nsLookAndFeel::NativeGetColor(const nsColorID aID, nscolor &aColor)
+{
+    nsresult rv = NS_OK;
+
+#define BASE_ACTIVE_COLOR     NS_RGB(0xaa,0xaa,0xaa)
+#define BASE_NORMAL_COLOR     NS_RGB(0xff,0xff,0xff)
+#define BASE_SELECTED_COLOR   NS_RGB(0xaa,0xaa,0xaa)
+#define BG_ACTIVE_COLOR       NS_RGB(0xff,0xff,0xff)
+#define BG_INSENSITIVE_COLOR  NS_RGB(0xaa,0xaa,0xaa)
+#define BG_NORMAL_COLOR       NS_RGB(0xff,0xff,0xff)
+#define BG_PRELIGHT_COLOR     NS_RGB(0xee,0xee,0xee)
+#define BG_SELECTED_COLOR     NS_RGB(0x99,0x99,0x99)
+#define DARK_NORMAL_COLOR     NS_RGB(0x88,0x88,0x88)
+#define FG_INSENSITIVE_COLOR  NS_RGB(0x44,0x44,0x44)
+#define FG_NORMAL_COLOR       NS_RGB(0x00,0x00,0x00)
+#define FG_PRELIGHT_COLOR     NS_RGB(0x77,0x77,0x77)
+#define FG_SELECTED_COLOR     NS_RGB(0xaa,0xaa,0xaa)
+#define LIGHT_NORMAL_COLOR    NS_RGB(0xaa,0xaa,0xaa)
+#define TEXT_ACTIVE_COLOR     NS_RGB(0x99,0x99,0x99)
+#define TEXT_NORMAL_COLOR     NS_RGB(0x00,0x00,0x00)
+#define TEXT_SELECTED_COLOR   NS_RGB(0x00,0x00,0x00)
+
+    // XXX we'll want to use context.obtainStyledAttributes on the java side to
+    // get all of these; see TextView.java for a good exmaple.
+
+    switch (aID) {
+        // These colors don't seem to be used for anything anymore in Mozilla
+        // (except here at least TextSelectBackground and TextSelectForeground)
+        // The CSS2 colors below are used.
+    case eColor_WindowBackground:
+        aColor = BASE_NORMAL_COLOR;
+        break;
+    case eColor_WindowForeground:
+        aColor = TEXT_NORMAL_COLOR;
+        break;
+    case eColor_WidgetBackground:
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor_WidgetForeground:
+        aColor = FG_NORMAL_COLOR;
+        break;
+    case eColor_WidgetSelectBackground:
+        aColor = BG_SELECTED_COLOR;
+        break;
+    case eColor_WidgetSelectForeground:
+        aColor = FG_SELECTED_COLOR;
+        break;
+    case eColor_Widget3DHighlight:
+        aColor = NS_RGB(0xa0,0xa0,0xa0);
+        break;
+    case eColor_Widget3DShadow:
+        aColor = NS_RGB(0x40,0x40,0x40);
+        break;
+    case eColor_TextBackground:
+        // not used?
+        aColor = BASE_NORMAL_COLOR;
+        break;
+    case eColor_TextForeground: 
+        // not used?
+        aColor = TEXT_NORMAL_COLOR;
+        break;
+    case eColor_TextSelectBackground:
+    case eColor_IMESelectedRawTextBackground:
+    case eColor_IMESelectedConvertedTextBackground:
+        // still used
+        aColor = BASE_SELECTED_COLOR;
+        break;
+    case eColor_TextSelectForeground:
+    case eColor_IMESelectedRawTextForeground:
+    case eColor_IMESelectedConvertedTextForeground:
+        // still used
+        aColor = TEXT_SELECTED_COLOR;
+        break;
+    case eColor_IMERawInputBackground:
+    case eColor_IMEConvertedTextBackground:
+        aColor = NS_TRANSPARENT;
+        break;
+    case eColor_IMERawInputForeground:
+    case eColor_IMEConvertedTextForeground:
+        aColor = NS_SAME_AS_FOREGROUND_COLOR;
+        break;
+    case eColor_IMERawInputUnderline:
+    case eColor_IMEConvertedTextUnderline:
+        aColor = NS_SAME_AS_FOREGROUND_COLOR;
+        break;
+    case eColor_IMESelectedRawTextUnderline:
+    case eColor_IMESelectedConvertedTextUnderline:
+        aColor = NS_TRANSPARENT;
+        break;
+    case eColor_SpellCheckerUnderline:
+      aColor = NS_RGB(0xff, 0, 0);
+      break;
+
+        // css2  http://www.w3.org/TR/REC-CSS2/ui.html#system-colors
+    case eColor_activeborder:
+        // active window border
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor_activecaption:
+        // active window caption background
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor_appworkspace:
+        // MDI background color
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor_background:
+        // desktop background
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor_captiontext:
+        // text in active window caption, size box, and scrollbar arrow box (!)
+        aColor = FG_NORMAL_COLOR;
+        break;
+    case eColor_graytext:
+        // disabled text in windows, menus, etc.
+        aColor = FG_INSENSITIVE_COLOR;
+        break;
+    case eColor_highlight:
+        // background of selected item
+        aColor = BASE_SELECTED_COLOR;
+        break;
+    case eColor_highlighttext:
+        // text of selected item
+        aColor = TEXT_SELECTED_COLOR;
+        break;
+    case eColor_inactiveborder:
+        // inactive window border
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor_inactivecaption:
+        // inactive window caption
+        aColor = BG_INSENSITIVE_COLOR;
+        break;
+    case eColor_inactivecaptiontext:
+        // text in inactive window caption
+        aColor = FG_INSENSITIVE_COLOR;
+        break;
+    case eColor_infobackground:
+        // tooltip background color
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor_infotext:
+        // tooltip text color
+        aColor = TEXT_NORMAL_COLOR;
+        break;
+    case eColor_menu:
+        // menu background
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor_menutext:
+        // menu text
+        aColor = TEXT_NORMAL_COLOR;
+        break;
+    case eColor_scrollbar:
+        // scrollbar gray area
+        aColor = BG_ACTIVE_COLOR;
+        break;
+
+    case eColor_threedface:
+    case eColor_buttonface:
+        // 3-D face color
+        aColor = BG_NORMAL_COLOR;
+        break;
+
+    case eColor_buttontext:
+        // text on push buttons
+        aColor = TEXT_NORMAL_COLOR;
+        break;
+
+    case eColor_buttonhighlight:
+        // 3-D highlighted edge color
+    case eColor_threedhighlight:
+        // 3-D highlighted outer edge color
+        aColor = LIGHT_NORMAL_COLOR;
+        break;
+
+    case eColor_threedlightshadow:
+        // 3-D highlighted inner edge color
+        aColor = BG_NORMAL_COLOR;
+        break;
+
+    case eColor_buttonshadow:
+        // 3-D shadow edge color
+    case eColor_threedshadow:
+        // 3-D shadow inner edge color
+        aColor = DARK_NORMAL_COLOR;
+        break;
+
+    case eColor_threeddarkshadow:
+        // 3-D shadow outer edge color
+        aColor = NS_RGB(0,0,0);
+        break;
+
+    case eColor_window:
+    case eColor_windowframe:
+        aColor = BG_NORMAL_COLOR;
+        break;
+
+    case eColor_windowtext:
+        aColor = FG_NORMAL_COLOR;
+        break;
+
+    case eColor__moz_eventreerow:
+    case eColor__moz_field:
+        aColor = BASE_NORMAL_COLOR;
+        break;
+    case eColor__moz_fieldtext:
+        aColor = TEXT_NORMAL_COLOR;
+        break;
+    case eColor__moz_dialog:
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor__moz_dialogtext:
+        aColor = FG_NORMAL_COLOR;
+        break;
+    case eColor__moz_dragtargetzone:
+        aColor = BG_SELECTED_COLOR;
+        break; 
+    case eColor__moz_buttondefault:
+        // default button border color
+        aColor = NS_RGB(0,0,0);
+        break;
+    case eColor__moz_buttonhoverface:
+        aColor = BG_PRELIGHT_COLOR;
+        break;
+    case eColor__moz_buttonhovertext:
+        aColor = FG_PRELIGHT_COLOR;
+        break;
+    case eColor__moz_cellhighlight:
+    case eColor__moz_html_cellhighlight:
+        aColor = BASE_ACTIVE_COLOR;
+        break;
+    case eColor__moz_cellhighlighttext:
+    case eColor__moz_html_cellhighlighttext:
+        aColor = TEXT_ACTIVE_COLOR;
+        break;
+    case eColor__moz_menuhover:
+        aColor = BG_PRELIGHT_COLOR;
+        break;
+    case eColor__moz_menuhovertext:
+        aColor = FG_PRELIGHT_COLOR;
+        break;
+    case eColor__moz_oddtreerow:
+        aColor = NS_TRANSPARENT;
+        break;
+    case eColor__moz_nativehyperlinktext:
+        aColor = NS_SAME_AS_FOREGROUND_COLOR;
+        break;
+    case eColor__moz_comboboxtext:
+        aColor = TEXT_NORMAL_COLOR;
+        break;
+    case eColor__moz_combobox:
+        aColor = BG_NORMAL_COLOR;
+        break;
+    case eColor__moz_menubartext:
+        aColor = TEXT_NORMAL_COLOR;
+        break;
+    case eColor__moz_menubarhovertext:
+        aColor = FG_PRELIGHT_COLOR;
+        break;
+    default:
+        /* default color is BLACK */
+        aColor = 0;
+        rv = NS_ERROR_FAILURE;
+        break;
+    }
+
+#if 0
+#define WHITE aColor = NS_RGB(0xff,0xff,0xff); break
+#define BLACK aColor = NS_RGB(0x00,0x00,0x00); break
+#define GRAY  aColor = NS_RGB(0xaa,0xaa,0xaa); break
+#define TRANSPARENT aColor = NS_TRANSPARENT; break
+#define FOREGROUND aColor = NS_SAME_AS_FOREGROUND_COLOR; break
+
+    switch (aID) {
+        case eColor_IMERawInputBackground:
+        case eColor_IMEConvertedTextBackground:
+        case eColor_IMESelectedRawTextUnderline:
+        case eColor_IMESelectedConvertedTextUnderline:
+            TRANSPARENT;
+
+        case eColor_IMERawInputForeground:
+        case eColor_IMEConvertedTextForeground:
+        case eColor_IMERawInputUnderline:
+        case eColor_IMEConvertedTextUnderline:
+            FOREGROUND;
+
+
+        case eColor_WindowBackground:
+        case eColor_WidgetSelectForeground:
+        case eColor_TextBackground:
+        case eColor_TextSelectForeground:
+        case eColor_IMESelectedRawTextBackground:
+        case eColor_IMESelectedConvertedTextBackground:
+        case eColor_background:
+        case eColor_inactiveborder:
+        case eColor_inactivecaption:
+        case eColor_inactivecaptiontext:
+        case eColor_infobackground:
+        case eColor_menu:
+        case eColor__moz_menubartext:
+        case eColor_scrollbar:
+        case eColor_threedface:
+        case eColor_buttonface:
+        case eColor_buttonhighlight:
+        case eColor_threedhighlight:
+            WHITE;
+
+        case eColor_IMESelectedRawTextForeground:
+        case eColor_IMESelectedConvertedTextForeground:
+        case eColor_IMERawInputForeground:
+        case eColor_IMEConvertedTextForeground:
+        case eColor_IMERawInputUnderline:
+        case eColor_IMEConvertedTextUnderline:
+        case eColor_IMESelectedRawTextUnderline:
+        case eColor_IMESelectedConvertedTextUnderline:
+        case eColor_SpellCheckerUnderline:
+        case eColor_infotext:
+        case eColor_menutext:
+        case eColor_WindowForeground:
+        case eColor_WidgetForeground:
+        case eColor_WidgetSelectBackground:
+        case eColor_TextForeground:
+        case eColor_TextSelectBackground:
+        case eColor_buttontext:
+        case eColor_windowtext:
+            BLACK;
+
+        case eColor_WidgetBackground:
+        case eColor_Widget3DHighlight:
+        case eColor_Widget3DShadow:
+        case eColor_activeborder:
+        case eColor_activecaption:
+        case eColor_appworkspace:
+        case eColor_captiontext:
+        case eColor_graytext:
+        case eColor_highlight:
+        case eColor_highlighttext:
+        case eColor_buttonshadow:
+        case eColor_threedshadow:
+        case eColor_threeddarkshadow:
+        case eColor_threedlightshadow:
+        case eColor_window:
+        case eColor_windowframe:
+            GRAY;
+
+            // from the CSS3 working draft (not yet finalized)
+            // http://www.w3.org/tr/2000/wd-css3-userint-20000216.html#color
+
+        case eColor__moz_buttondefault:
+        case eColor__moz_field:
+        case eColor__moz_combobox:
+        case eColor__moz_dialog:
+        case eColor__moz_dragtargetzone:
+            GRAY;
+            
+        case eColor__moz_fieldtext:
+        case eColor__moz_comboboxtext:
+        case eColor__moz_dialogtext:
+        case eColor__moz_buttonhovertext:
+        case eColor__moz_menuhovertext:
+        case eColor__moz_menubarhovertext:
+            BLACK;
+
+        default:
+            aColor = 0;
+            rv = NS_ERROR_FAILURE;
+            break;
+    }
+#endif
+
+    return rv;
+}
+
+
+NS_IMETHODIMP
+nsLookAndFeel::GetMetric(const nsMetricID aID, PRInt32 &aMetric)
+{
+    nsresult rv = nsXPLookAndFeel::GetMetric(aID, aMetric);
+    if (NS_SUCCEEDED(rv))
+        return rv;
+
+    rv = NS_OK;
+
+    switch (aID) {
+        case eMetric_WindowTitleHeight:
+        case eMetric_WindowBorderWidth:
+        case eMetric_WindowBorderHeight:
+            aMetric = 0;
+            break;
+
+        case eMetric_Widget3DBorder:
+            aMetric = 4;
+            break;
+
+        case eMetric_TextFieldHeight:
+            aMetric = 15;
+            break;
+
+        case eMetric_TextFieldBorder:
+            aMetric = 2;
+            break;
+
+        case eMetric_TextVerticalInsidePadding:
+            aMetric = 0;
+            break;
+
+        case eMetric_TextShouldUseVerticalInsidePadding:
+            aMetric = 0;
+            break;
+
+        case eMetric_TextHorizontalInsideMinimumPadding:
+            aMetric = 15;
+            break;
+
+        case eMetric_TextShouldUseHorizontalInsideMinimumPadding:
+            aMetric = 1;
+            break;
+
+        case eMetric_ButtonHorizontalInsidePaddingNavQuirks:
+            aMetric = 10;
+            break;
+
+        case eMetric_ButtonHorizontalInsidePaddingOffsetNavQuirks:
+            aMetric = 8;
+            break;
+
+        case eMetric_CheckboxSize:
+        case eMetric_RadioboxSize:
+            aMetric = 15;
+            break;
+
+        case eMetric_ListShouldUseHorizontalInsideMinimumPadding:
+            aMetric = 15;
+            break;
+
+        case eMetric_ListHorizontalInsideMinimumPadding:
+            aMetric = 15;
+            break;
+
+        case eMetric_ListShouldUseVerticalInsidePadding:
+            aMetric = 1;
+            break;
+
+        case eMetric_ListVerticalInsidePadding:
+            aMetric = 1;
+            break;
+
+        case eMetric_CaretBlinkTime:
+            aMetric = 500;
+            break;
+
+        case eMetric_CaretWidth:
+            aMetric = 1;
+            break;
+
+        case eMetric_ShowCaretDuringSelection:
+            aMetric = 0;
+            break;
+
+        case eMetric_SelectTextfieldsOnKeyFocus:
+            // Select textfield content when focused by kbd
+            // used by nsEventStateManager::sTextfieldSelectModel
+            aMetric = 1;
+            break;
+
+        case eMetric_SubmenuDelay:
+            aMetric = 200;
+            break;
+
+        case eMetric_MenusCanOverlapOSBar:
+            // we want XUL popups to be able to overlap the task bar.
+            aMetric = 1;
+            break;
+
+        case eMetric_ScrollArrowStyle:
+            aMetric = eMetric_ScrollArrowStyleSingle;
+            break;
+
+        case eMetric_ScrollSliderStyle:
+            aMetric = eMetric_ScrollThumbStyleProportional;
+            break;
+
+        case eMetric_WindowsDefaultTheme:
+        case eMetric_TouchEnabled:
+        case eMetric_MaemoClassic:
+            aMetric = 0;
+            rv = NS_ERROR_NOT_IMPLEMENTED;
+            break;
+
+        case eMetric_SpellCheckerUnderlineStyle:
+            aMetric = NS_UNDERLINE_STYLE_WAVY;
+            break;
+
+        default:
+            aMetric = 0;
+            rv = NS_ERROR_FAILURE;
+    }
+
+    return rv;
+}
+
+NS_IMETHODIMP
+nsLookAndFeel::GetMetric(const nsMetricFloatID aID,
+                         float &aMetric)
+{
+    nsresult rv = nsXPLookAndFeel::GetMetric(aID, aMetric);
+    if (NS_SUCCEEDED(rv))
+        return rv;
+    rv = NS_OK;
+
+    switch (aID) {
+        case eMetricFloat_TextFieldVerticalInsidePadding:
+            aMetric = 0.25f;
+            break;
+
+        case eMetricFloat_TextFieldHorizontalInsidePadding:
+            aMetric = 0.95f; // large number on purpose so minimum padding is used
+            break;
+
+        case eMetricFloat_TextAreaVerticalInsidePadding:
+            aMetric = 0.40f;
+            break;
+
+        case eMetricFloat_TextAreaHorizontalInsidePadding:
+            aMetric = 0.40f; // large number on purpose so minimum padding is used
+            break;
+
+        case eMetricFloat_ListVerticalInsidePadding:
+            aMetric = 0.10f;
+            break;
+
+        case eMetricFloat_ListHorizontalInsidePadding:
+            aMetric = 0.40f;
+            break;
+
+        case eMetricFloat_ButtonVerticalInsidePadding:
+            aMetric = 0.25f;
+            break;
+
+        case eMetricFloat_ButtonHorizontalInsidePadding:
+            aMetric = 0.25f;
+            break;
+
+        case eMetricFloat_IMEUnderlineRelativeSize:
+            aMetric = 1.0f;
+            break;
+
+        case eMetricFloat_SpellCheckerUnderlineRelativeSize:
+            aMetric = 1.0f;
+            break;
+
+        default:
+            aMetric = -1.0;
+            rv = NS_ERROR_FAILURE;
+            break;
+    }
+    return rv;
+}
diff --git a/widget/src/webos/nsLookAndFeel.h b/widget/src/webos/nsLookAndFeel.h
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsLookAndFeel.h
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Lars Knoll <knoll@kde.org>
+ *   John C. Griggs <johng@corel.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef __nsLookAndFeel
+#define __nsLookAndFeel
+
+#include "nsXPLookAndFeel.h"
+
+class nsLookAndFeel: public nsXPLookAndFeel
+{
+public:
+    nsLookAndFeel();
+    virtual ~nsLookAndFeel();
+
+    nsresult NativeGetColor(const nsColorID aID, nscolor &aColor);
+    NS_IMETHOD GetMetric(const nsMetricID aID, PRInt32 & aMetric);
+    NS_IMETHOD GetMetric(const nsMetricFloatID aID, float & aMetric);
+};
+
+#endif
diff --git a/widget/src/webos/nsScreenManager.cpp b/widget/src/webos/nsScreenManager.cpp
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsScreenManager.cpp
@@ -0,0 +1,142 @@
+/* -*- Mode: C++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Dave Townsend <dtownsend@oxymoronical.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsScreenManager.h"
+#include "nsWindow.h"
+#include "prlog.h"
+#include "nsAppShell.h"
+
+PRLogModuleInfo* gScreenManagerLog = nsnull;
+
+NS_IMPL_ISUPPORTS1(nsWebOSScreen, nsIScreen)
+
+nsWebOSScreen::nsWebOSScreen(void *nativeScreen)
+{
+}
+
+nsWebOSScreen::~nsWebOSScreen()
+{
+}
+
+NS_IMETHODIMP
+nsWebOSScreen::GetRect(PRInt32 *outLeft, PRInt32 *outTop, PRInt32 *outWidth, PRInt32 *outHeight)
+{
+    *outLeft = 0;
+    *outTop = 0;
+
+    *outWidth = nsAppShell::gAppShell->mScreenBounds.width;
+    *outHeight = nsAppShell::gAppShell->mScreenBounds.width;
+
+    return NS_OK;
+}
+
+
+NS_IMETHODIMP
+nsWebOSScreen::GetAvailRect(PRInt32 *outLeft, PRInt32 *outTop, PRInt32 *outWidth, PRInt32 *outHeight)
+{
+    return GetRect(outLeft, outTop, outWidth, outHeight);
+}
+
+
+
+NS_IMETHODIMP 
+nsWebOSScreen::GetPixelDepth(PRInt32 *aPixelDepth)
+{
+    // XXX do we need to lie here about 16bpp?  Or
+    // should we actually check and return the right thing?
+    *aPixelDepth = 24;
+    return NS_OK;
+}
+
+
+NS_IMETHODIMP 
+nsWebOSScreen::GetColorDepth(PRInt32 *aColorDepth)
+{
+    return GetPixelDepth(aColorDepth);
+}
+
+NS_IMPL_ISUPPORTS1(nsScreenManager, nsIScreenManager)
+
+nsScreenManager::nsScreenManager()
+{
+#if defined(PR_LOGGING)
+    if (!gScreenManagerLog) {
+        gScreenManagerLog = PR_NewLogModule("nsScreenManager");
+    }
+#endif
+
+    PR_LOG(gScreenManagerLog, PR_LOG_DEBUG, ("Init"));
+    mOneScreen = new nsWebOSScreen(nsnull);
+}
+
+nsScreenManager::~nsScreenManager()
+{
+    PR_LOG(gScreenManagerLog, PR_LOG_DEBUG, ("Destroy"));
+}
+
+NS_IMETHODIMP
+nsScreenManager::GetPrimaryScreen(nsIScreen **outScreen)
+{
+    NS_IF_ADDREF(*outScreen = mOneScreen.get());
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsScreenManager::ScreenForRect(PRInt32 inLeft,
+                               PRInt32 inTop,
+                               PRInt32 inWidth,
+                               PRInt32 inHeight,
+                               nsIScreen **outScreen)
+{
+    return GetPrimaryScreen(outScreen);
+}
+
+NS_IMETHODIMP
+nsScreenManager::ScreenForNativeWidget(void *aWidget, nsIScreen **outScreen)
+{
+    return GetPrimaryScreen(outScreen);
+}
+
+NS_IMETHODIMP
+nsScreenManager::GetNumberOfScreens(PRUint32 *aNumberOfScreens)
+{
+    *aNumberOfScreens = 1;
+    return NS_OK;
+}
+
diff --git a/widget/src/webos/nsScreenManager.h b/widget/src/webos/nsScreenManager.h
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsScreenManager.h
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Dave Townsend <dtownsend@oxymoronical.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsScreenManagerWebOS_h___
+#define nsScreenManagerWebOS_h___
+
+#include "nsCOMPtr.h"
+
+#include "nsIScreenManager.h"
+#include "nsIScreen.h"
+
+class nsWebOSScreen :
+    public nsIScreen
+{
+public:
+    nsWebOSScreen(void *platformScreen);
+    ~nsWebOSScreen();
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSISCREEN
+};
+
+class nsScreenManager :
+    public nsIScreenManager
+{
+public:
+    nsScreenManager();
+    ~nsScreenManager();
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSISCREENMANAGER
+
+protected:
+    nsCOMPtr<nsIScreen> mOneScreen;
+};
+
+#endif /* nsScreenManagerWebOS_h___ */
diff --git a/widget/src/webos/nsToolkit.cpp b/widget/src/webos/nsToolkit.cpp
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsToolkit.cpp
@@ -0,0 +1,96 @@
+/* -*- Mode: C++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsToolkit.h"
+#include "nsGUIEvent.h"
+#include "nsWidgetAtoms.h"
+
+NS_IMPL_ISUPPORTS1(nsToolkit, nsIToolkit)
+
+// why do we have this?
+static PRUintn gToolkitTLSIndex = 0;
+
+nsToolkit::nsToolkit()
+{
+}
+
+nsToolkit::~nsToolkit()
+{
+    PR_SetThreadPrivate(gToolkitTLSIndex, nsnull);
+}
+
+NS_IMETHODIMP
+nsToolkit::Init(PRThread *aThread)
+{
+    nsWidgetAtoms::RegisterAtoms();
+    return NS_OK;
+}
+
+NS_METHOD
+NS_GetCurrentToolkit(nsIToolkit* *aResult)
+{
+    nsCOMPtr<nsIToolkit> toolkit = nsnull;
+    nsresult rv = NS_OK;
+    PRStatus status;
+
+    if (gToolkitTLSIndex == 0) {
+        status = PR_NewThreadPrivateIndex(&gToolkitTLSIndex, NULL);
+        if (PR_FAILURE == status)
+            rv = NS_ERROR_FAILURE;
+    }
+
+    if (NS_FAILED(rv))
+        return rv;
+
+    toolkit = (nsIToolkit*) PR_GetThreadPrivate(gToolkitTLSIndex);
+    if (!toolkit) {
+        toolkit = new nsToolkit();
+
+        if (toolkit) {
+            toolkit->Init(PR_GetCurrentThread());
+
+            PR_SetThreadPrivate(gToolkitTLSIndex, (void*)toolkit.get());
+        } else {
+            rv = NS_ERROR_OUT_OF_MEMORY;
+        }
+    }
+
+    NS_IF_ADDREF(*aResult = toolkit);
+
+    return rv;
+}
diff --git a/widget/src/webos/nsToolkit.h b/widget/src/webos/nsToolkit.h
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsToolkit.h
@@ -0,0 +1,57 @@
+/* -*- Mode: c++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4; -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsToolkit_h__
+#define nsToolkit_h__
+
+#include <nsIToolkit.h>
+
+class nsToolkit :
+    public nsIToolkit
+{
+public:
+    NS_DECL_ISUPPORTS
+
+    // nsIToolkit
+    NS_IMETHOD		Init(PRThread *aThread);
+
+    nsToolkit();
+    virtual ~nsToolkit();
+};
+
+#endif /* nsToolkit_h__ */
diff --git a/widget/src/webos/nsWidgetFactory.cpp b/widget/src/webos/nsWidgetFactory.cpp
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsWidgetFactory.cpp
@@ -0,0 +1,110 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corp
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Dave Townsend <dtownsend@oxymoronical.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "mozilla/ModuleUtils.h"
+
+#include "nsCOMPtr.h"
+#include "nsWidgetsCID.h"
+#include "nsAppShell.h"
+#include "nsToolkit.h"
+
+#include "nsWindow.h"
+#include "nsLookAndFeel.h"
+#include "nsAppShellSingleton.h"
+#include "nsScreenManager.h"
+#include "nsIdleServiceWebOS.h"
+
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsToolkit)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsWindow)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsLookAndFeel)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsScreenManager)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsIdleServiceWebOS)
+
+NS_DEFINE_NAMED_CID(NS_TOOLKIT_CID);
+NS_DEFINE_NAMED_CID(NS_APPSHELL_CID);
+NS_DEFINE_NAMED_CID(NS_WINDOW_CID);
+NS_DEFINE_NAMED_CID(NS_CHILD_CID);
+NS_DEFINE_NAMED_CID(NS_LOOKANDFEEL_CID);
+NS_DEFINE_NAMED_CID(NS_SCREENMANAGER_CID);
+NS_DEFINE_NAMED_CID(NS_IDLE_SERVICE_CID);
+
+static const mozilla::Module::CIDEntry kWidgetCIDs[] = {
+    { &kNS_TOOLKIT_CID, false, NULL, nsToolkitConstructor },
+    { &kNS_APPSHELL_CID, false, NULL, nsAppShellConstructor },
+    { &kNS_WINDOW_CID, false, NULL, nsWindowConstructor },
+    { &kNS_CHILD_CID, false, NULL, nsWindowConstructor }, /* Note: same as Window! */
+    { &kNS_LOOKANDFEEL_CID, false, NULL, nsLookAndFeelConstructor },
+    { &kNS_SCREENMANAGER_CID, false, NULL, nsScreenManagerConstructor },
+    { &kNS_IDLE_SERVICE_CID, false, NULL, nsIdleServiceWebOSConstructor },
+    { NULL }
+};
+
+static const mozilla::Module::ContractIDEntry kWidgetContracts[] = {
+    { "@mozilla.org/widget/toolkit/webos;1", &kNS_TOOLKIT_CID },
+    { "@mozilla.org/widget/appshell/webos;1", &kNS_APPSHELL_CID },
+    { "@mozilla.org/widgets/window/webos;1", &kNS_WINDOW_CID },
+    { "@mozilla.org/widgets/child_window/webos;1", &kNS_CHILD_CID },
+    { "@mozilla.org/widget/lookandfeel/webos;1", &kNS_LOOKANDFEEL_CID },
+    { "@mozilla.org/gfx/screenmanager;1", &kNS_SCREENMANAGER_CID },
+    { "@mozilla.org/widget/idleservice;1", &kNS_IDLE_SERVICE_CID },
+    { NULL }
+};
+
+static void
+nsWidgetWebOSModuleDtor()
+{
+    if (SDL_WasInit(SDL_INIT_VIDEO) == 0) {
+        printf("SDL Quit\n");
+        SDL_Quit();
+    }
+
+    nsAppShellShutdown();
+}
+
+static const mozilla::Module kWidgetModule = {
+    mozilla::Module::kVersion,
+    kWidgetCIDs,
+    kWidgetContracts,
+    NULL,
+    NULL,
+    nsAppShellInit,
+    nsWidgetWebOSModuleDtor
+};
+
+NSMODULE_DEFN(nsWidgetWebOSModule) = &kWidgetModule;
diff --git a/widget/src/webos/nsWindow.cpp b/widget/src/webos/nsWindow.cpp
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsWindow.cpp
@@ -0,0 +1,1270 @@
+/* -*- Mode: c++; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Android code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Dave Townsend <dtownsend@oxymoronical.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsWindow.h"
+#include "nsScreenManager.h"
+#include "nsAppShell.h"
+#include "prlog.h"
+#include "nsWidgetAtoms.h"
+
+#include "nsIDeviceContext.h"
+#include "nsIRenderingContext.h"
+
+#include "nsWidgetsCID.h"
+#include "nsGfxCIID.h"
+
+#include "gfxImageSurface.h"
+#include "gfxContext.h"
+
+#include "Layers.h"
+#include "BasicLayers.h"
+#include "LayerManagerOGL.h"
+
+#include "nsTArray.h"
+
+using namespace mozilla;
+
+PRLogModuleInfo* gWindowLog = nsnull;
+PRLogModuleInfo* gWindowEventLog = nsnull;
+
+NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
+
+static PRUint8 gMeta = 0;
+static PRUint8 gShift = 0;
+
+PRUint32 gLastInputEventTime = 0;
+
+// All the toplevel windows that have been created; these are in
+// stacking order, so the window at gTopLevelWindows[0] is the topmost
+// one.
+static nsTArray<nsWindow*> gTopLevelWindows;
+static nsWindow* gFocusedWindow = nsnull;
+
+PRUint32 nsWindow::mButtonCount = 0;
+nsRefPtr<nsWindow> nsWindow::mGestureWindow = nsnull;
+
+static nsWindow*
+TopWindow() {
+    if (gTopLevelWindows.Length() > 0)
+        return gTopLevelWindows[0];
+    return nsnull;
+}
+
+void
+nsWindow::LogWindow(nsWindow *win, int index, int indent)
+{
+    char spaces[] = "                    ";
+    spaces[indent < 20 ? indent : 20] = 0;
+    PR_LOG(gWindowLog, PR_LOG_DEBUG,
+           ("%s [% 2d] 0x%08x [% 3d,% 3d % 3dx% 3d] vis %d type %d",
+            spaces, index, (void*)win,
+            win->mBounds.x, win->mBounds.y,
+            win->mBounds.width, win->mBounds.height,
+            win->mIsVisible, win->mContentType));
+}
+
+void
+nsWindow::DumpWindows()
+{
+    DumpWindows(gTopLevelWindows);
+}
+
+void
+nsWindow::DumpWindows(const nsTArray<nsWindow*>& wins, int indent)
+{
+    if (PR_LOG_TEST(gWindowLog, PR_LOG_DEBUG)) {
+        for (unsigned int i = 0; i < wins.Length(); ++i) {
+            nsWindow *w = wins[i];
+            LogWindow(w, i, indent);
+            DumpWindows(w->mChildren, indent + 2);
+        }
+    }
+}
+
+nsWindow::nsWindow()
+{
+#ifdef PR_LOGGING
+    if (!gWindowLog)
+        gWindowLog = PR_NewLogModule("nsWindow");
+    if (!gWindowEventLog)
+        gWindowEventLog = PR_NewLogModule("nsWindowEvents");
+#endif
+
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x initialized", (void*)this));
+
+    mIsVisible = PR_FALSE;
+    mParent = nsnull;
+    mLastClickTime = 0;
+    mClickCount = 0;
+}
+
+nsWindow::~nsWindow()
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x destroyed", (void*)this));
+}
+
+PRBool
+nsWindow::IsTopLevel()
+{
+    return mWindowType == eWindowType_toplevel ||
+        mWindowType == eWindowType_dialog ||
+        mWindowType == eWindowType_invisible;
+}
+
+NS_IMETHODIMP
+nsWindow::Create(nsIWidget *aParent,
+                 nsNativeWidget aNativeParent,
+                 const nsIntRect &aRect,
+                 EVENT_CALLBACK aHandleEventFunction,
+                 nsIDeviceContext *aContext,
+                 nsIAppShell *aAppShell,
+                 nsIToolkit *aToolkit,
+                 nsWidgetInitData *aInitData)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x Create", (void*)this));
+    nsWindow *parent = (nsWindow*) aParent;
+
+    if (aNativeParent) {
+        if (parent) {
+            PR_LOG(gWindowLog, PR_LOG_WARNING,
+                   ("Ignoring native parent since gecko parent was specified (0x%08x 0x%08x)",
+                    (void*)aNativeParent, (void*)aParent));
+        } else {
+            parent = (nsWindow*) aNativeParent;
+        }
+    }
+
+    mBounds = aRect;
+
+    // for toplevel windows, bounds are fixed to full screen size
+    if (parent == nsnull) {
+        mBounds.x = 0;
+        mBounds.y = 0;
+        mBounds.width = nsAppShell::gAppShell->mScreenBounds.width;
+        mBounds.height = nsAppShell::gAppShell->mScreenBounds.height;
+    }
+
+    BaseCreate(nsnull, mBounds, aHandleEventFunction, aContext,
+               aAppShell, aToolkit, aInitData);
+
+    NS_ASSERTION(IsTopLevel() || parent, "non top level window doesn't have a parent!");
+
+    mContentType = aInitData ? aInitData->mContentType : eContentTypeInherit;
+
+    if (IsTopLevel()) {
+        gTopLevelWindows.AppendElement(this);
+    }
+
+    if (parent) {
+        parent->mChildren.AppendElement(this);
+        mParent = parent;
+    }
+
+    DumpWindows();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Destroy(void)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x Destroy", (void*)this));
+
+    for (PRUint32 i = 0; i < mChildren.Length(); ++i) {
+        // why do we still have children?
+        PR_LOG(gWindowLog, PR_LOG_WARNING,
+               ("Reparenting child 0x%08x to null!", (void*)mChildren[i]));
+        mChildren[i]->SetParent(nsnull);
+    }
+
+    if (IsTopLevel())
+        gTopLevelWindows.RemoveElement(this);
+
+    if (mParent)
+        mParent->mChildren.RemoveElement(this);
+
+    DumpWindows();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::ConfigureChildren(const nsTArray<nsIWidget::Configuration>& config)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x ConfigureChildren()", (void*)this));
+
+    for (PRUint32 i = 0; i < config.Length(); ++i) {
+        nsWindow *childWin = (nsWindow*) config[i].mChild;
+        childWin->Resize(config[i].mBounds.x,
+                         config[i].mBounds.y,
+                         config[i].mBounds.width,
+                         config[i].mBounds.height,
+                         PR_FALSE);
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetParent(nsIWidget *aNewParent)
+{
+    if ((nsIWidget*)mParent == aNewParent)
+        return NS_OK;
+
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x SetParent(0x%08x)",
+                                      (void*)this, (void*)aNewParent));
+
+    // If we had a parent before, remove ourselves from its list of
+    // children.  If we didn't have a parent, then remove ourselves
+    // from the list of toplevel windows if we're about to get a
+    // parent.
+    if (mParent)
+        mParent->mChildren.RemoveElement(this);
+
+    mParent = (nsWindow*)aNewParent;
+
+    if (mParent)
+        mParent->mChildren.AppendElement(this);
+
+    // if we are now in the toplevel window's hierarchy, schedule a redraw
+    if (FindTopLevel() == TopWindow()) {
+        nsAppShell::ScheduleRedraw();
+    }
+
+    return NS_OK;
+}
+
+nsIWidget*
+nsWindow::GetParent()
+{
+    return mParent;
+}
+
+NS_IMETHODIMP
+nsWindow::Show(PRBool aState)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG,
+           ("Window 0x%08x Show(%d)", (void*)this, aState));
+
+    if (mWindowType == eWindowType_invisible) {
+        PR_LOG(gWindowLog, PR_LOG_WARNING, ("Trying to show invisible window! ignoring..."));
+        return NS_ERROR_FAILURE;
+    }
+
+    if ((aState && !mIsVisible) ||
+        (!aState && mIsVisible))
+    {
+        mIsVisible = aState;
+
+        if (IsTopLevel()) {
+            // XXX should we bring this to the front when it's shown,
+            // if it's a toplevel widget?
+
+            // XXX we should synthesize a NS_MOUSE_EXIT (for old top
+            // window)/NS_MOUSE_ENTER (for new top window) since we need
+            // to pretend that the top window always has focus.  Not sure
+            // if Show() is the right place to do this, though.
+
+            if (mIsVisible) {
+                // It just became visible, so send a resize update if necessary
+                // and bring it to the front.
+                Resize(0, 0, nsAppShell::gAppShell->mScreenBounds.width,
+                       nsAppShell::gAppShell->mScreenBounds.height, PR_FALSE);
+                BringToFront();
+            }
+        } else if (FindTopLevel() == TopWindow()) {
+            nsAppShell::ScheduleRedraw();
+        }
+    }
+
+    DumpWindows();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetModal(PRBool aState)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x SetModal(%d) ignored", (void*)this, aState));
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::IsVisible(PRBool& aState)
+{
+    aState = mIsVisible;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::ConstrainPosition(PRBool aAllowSlop,
+                            PRInt32 *aX,
+                            PRInt32 *aY)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x ConstrainPosition %d [% 3d,% 3d]",
+           (void*)this, aAllowSlop, *aX, *aY));
+
+    // constrain toplevel windows; children we don't care about
+    if (IsTopLevel()) {
+        *aX = 0;
+        *aY = 0;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Move(PRInt32 aX,
+               PRInt32 aY)
+{
+    if (IsTopLevel())
+        return NS_OK;
+
+    return Resize(aX,
+                  aY,
+                  mBounds.width,
+                  mBounds.height,
+                  PR_TRUE);
+}
+
+NS_IMETHODIMP
+nsWindow::Resize(PRInt32 aWidth,
+                 PRInt32 aHeight,
+                 PRBool aRepaint)
+{
+    return Resize(mBounds.x,
+                  mBounds.y,
+                  aWidth,
+                  aHeight,
+                  aRepaint);
+}
+
+NS_IMETHODIMP
+nsWindow::Resize(PRInt32 aX,
+                 PRInt32 aY,
+                 PRInt32 aWidth,
+                 PRInt32 aHeight,
+                 PRBool aRepaint)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG,
+           ("Window 0x%08x Resize [% 3d,% 3d % 3dx% 3d] (repaint %d)",
+            (void*)this, aX, aY, aWidth, aHeight, aRepaint));
+
+    if (IsTopLevel()) {
+        PR_LOG(gWindowLog, PR_LOG_DEBUG, ("... ignoring Resize sizes on toplevel window"));
+        aX = 0;
+        aY = 0;
+        aWidth = nsAppShell::gAppShell->mScreenBounds.width;
+        aHeight = nsAppShell::gAppShell->mScreenBounds.height;
+    }
+
+    PRBool needSizeDispatch = aWidth != mBounds.width || aHeight != mBounds.height;
+
+    mBounds.x = aX;
+    mBounds.y = aY;
+    mBounds.width = aWidth;
+    mBounds.height = aHeight;
+
+    if (needSizeDispatch)
+        OnSizeChanged(gfxIntSize(aWidth, aHeight));
+
+    // Should we skip honoring aRepaint here?
+    if (aRepaint && FindTopLevel() == TopWindow()) {
+        nsAppShell::ScheduleRedraw();
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetZIndex(PRInt32 aZIndex)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x SetZIndex(%d) ignored", (void*)this, aZIndex));
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
+                      nsIWidget *aWidget,
+                      PRBool aActivate)
+{
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetSizeMode(PRInt32 aMode)
+{
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Enable(PRBool aState)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x Enable(%d) ignored", (void*)this, aState));
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::IsEnabled(PRBool *aState)
+{
+    *aState = PR_TRUE;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Invalidate(const nsIntRect &aRect,
+                     PRBool aIsSynchronous)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x Invalidate", (void*)this));
+    nsAppShell::ScheduleRedraw();
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Update()
+{
+    return NS_OK;
+}
+
+void
+nsWindow::Scroll(const nsIntPoint&,
+                 const nsTArray<nsIntRect>&,
+                 const nsTArray<nsIWidget::Configuration>&)
+{
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x Scroll ignored", (void*)this));
+}
+
+nsWindow*
+nsWindow::FindTopLevel()
+{
+    nsWindow *toplevel = this;
+    while (toplevel) {
+        if (toplevel->IsTopLevel())
+            return toplevel;
+
+        toplevel = toplevel->mParent;
+    }
+
+    PR_LOG(gWindowLog, PR_LOG_WARNING,
+           ("Window 0x%08x FindTopLevel could not find a toplevel window", (void*)this));
+    return this;
+}
+
+NS_IMETHODIMP
+nsWindow::SetFocus(PRBool aRaise)
+{
+    if (!aRaise) {
+        PR_LOG(gWindowLog, PR_LOG_WARNING,
+               ("Window 0x%08x SetFocus, can't set focus without raising, ignoring aRaise = false!",
+                (void*)this));
+    }
+
+    gFocusedWindow = this;
+    FindTopLevel()->BringToFront();
+
+    return NS_OK;
+}
+
+void
+nsWindow::BringToFront()
+{
+    if (FindTopLevel() == TopWindow())
+        return;
+
+    if (!IsTopLevel()) {
+        FindTopLevel()->BringToFront();
+        return;
+    }
+
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x BringToFront", (void*)this));
+
+    nsWindow *oldTop = nsnull;
+    if (gTopLevelWindows.Length())
+        oldTop = gTopLevelWindows[0];
+
+    gTopLevelWindows.RemoveElement(this);
+    gTopLevelWindows.InsertElementAt(0, this);
+
+    if (oldTop) {
+        nsGUIEvent event(PR_TRUE, NS_DEACTIVATE, gTopLevelWindows[0]);
+        DispatchEvent(&event);
+    }
+
+    nsGUIEvent event(PR_TRUE, NS_ACTIVATE, this);
+    DispatchEvent(&event);
+
+    nsAppShell::ScheduleRedraw();
+}
+
+NS_IMETHODIMP
+nsWindow::GetScreenBounds(nsIntRect &aRect)
+{
+    nsIntPoint p = WidgetToScreenOffset();
+
+    aRect.x = p.x;
+    aRect.y = p.y;
+    aRect.width = mBounds.width;
+    aRect.height = mBounds.height;
+
+    return NS_OK;
+}
+
+nsIntPoint
+nsWindow::WidgetToScreenOffset()
+{
+    nsIntPoint p(0, 0);
+    nsWindow *w = this;
+
+    while (w && !w->IsTopLevel()) {
+        p.x += w->mBounds.x;
+        p.y += w->mBounds.y;
+
+        w = w->mParent;
+    }
+
+    return p;
+}
+
+NS_IMETHODIMP
+nsWindow::DispatchEvent(nsGUIEvent *aEvent,
+                        nsEventStatus &aStatus)
+{
+    aStatus = DispatchEvent(aEvent);
+    return NS_OK;
+}
+
+nsEventStatus
+nsWindow::DispatchEvent(nsGUIEvent *aEvent)
+{
+    if (mEventCallback)
+        return (*mEventCallback)(aEvent);
+    return nsEventStatus_eIgnore;
+}
+
+NS_IMETHODIMP
+nsWindow::SetWindowClass(const nsAString& xulWinType)
+{
+    return NS_OK;
+}
+
+gfxASurface*
+nsWindow::GetThebesSurface()
+{
+    /* This is really a dummy surface; this is only used when doing reflow, because
+     * we need a RenderingContext to measure text against.
+     */
+
+    // XXX this really wants to return already_AddRefed, but this only really gets used
+    // on direct assignment to a gfxASurface
+    return new gfxImageSurface(gfxIntSize(5,5), gfxImageSurface::ImageFormatRGB24);
+}
+
+nsIntPoint
+nsWindow::TranslateScreenPoint(int x, int y)
+{
+    gfxPoint point = nsAppShell::gAppShell->mEventTransform.Transform(gfxPoint(x, y));
+    nsIntPoint result(point.x, point.y);
+    return result;
+}
+
+void
+nsWindow::OnGlobalSDLEvent(SDL_Event *sdlevt)
+{
+    switch (sdlevt->type) {
+    case SDL_KEYDOWN:
+    case SDL_KEYUP:
+        if (gFocusedWindow) {
+            gFocusedWindow->OnSDLEvent(sdlevt);
+            break;
+        }
+    case WEBOS_EVENT_REDRAW:
+    case SDL_VIDEORESIZE:
+        if (gTopLevelWindows.Length() > 0)
+            gTopLevelWindows[0]->OnSDLEvent(sdlevt);
+        break;
+    case SDL_MOUSEMOTION:
+    case SDL_MOUSEBUTTONUP:
+    case SDL_MOUSEBUTTONDOWN:
+        gLastInputEventTime = PR_IntervalToMicroseconds(PR_IntervalNow());
+
+        PRUint32 buttonCount = 0;
+
+        int x, y;
+        nsIntPoint center(0, 0);
+        nsIntPoint *points = new nsIntPoint[SDL_MAXMOUSE];
+        for (unsigned int i = 0; i < SDL_MAXMOUSE; i++) {
+            if (SDL_GetMultiMouseState(i, &x, &y) == 0)
+                continue;
+            points[buttonCount] = TranslateScreenPoint(x, y);
+            buttonCount++;
+            center.x += points[i].x;
+            center.y += points[i].y;
+        }
+        center.x /= buttonCount;
+        center.y /= buttonCount;
+
+        PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Mouse event with %d buttons", buttonCount));
+
+        if (gTopLevelWindows.Length() == 0)
+            return;
+
+        if (buttonCount == 0)
+            center = TranslateScreenPoint(sdlevt->button.x, sdlevt->button.y);
+
+        nsWindow* win = gTopLevelWindows[0]->FindWindowForPoint(center);
+
+        if (buttonCount > 0 && buttonCount == mButtonCount) {
+            if (mButtonCount == 1) {
+                if (win)
+                    win->OnMouseEvent(NS_MOUSE_MOVE, center);
+                PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Mouse move"));
+            }
+            else {
+                if (mGestureWindow)
+                    mGestureWindow->OnGestureMove(center, points, buttonCount);
+                PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Gesture move (%d)", mButtonCount));
+            }
+            return;
+        }
+
+        if (mButtonCount > 1) {
+            if (mGestureWindow)
+                mGestureWindow->OnGestureEnd(mButtonCount);
+            mGestureWindow = nsnull;
+            PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Gesture end (%d)", mButtonCount));
+        }
+
+        if (buttonCount == 0) {
+            if (win)
+                win->OnMouseEvent(NS_MOUSE_BUTTON_UP, center);
+            PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Mouse up"));
+        }
+        else if (buttonCount == 1 && mButtonCount == 0) {
+            if (sdlevt->type == SDL_MOUSEMOTION) {
+                if (win)
+                    win->OnMouseEvent(NS_MOUSE_MOVE, center);
+                PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Mouse motion"));
+                return;
+            }
+
+            if (win)
+                win->OnMouseEvent(NS_MOUSE_BUTTON_DOWN, center);
+            PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Mouse down"));
+        }
+
+        mButtonCount = buttonCount;
+
+        if (mButtonCount > 1) {
+            if (!mGestureWindow)
+                mGestureWindow = win;
+            if (mGestureWindow)
+                mGestureWindow->OnGestureStart(center, points, mButtonCount);
+            PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Gesture start (%d)", mButtonCount));
+        }
+        break;
+    }
+}
+
+void
+nsWindow::OnSDLEvent(SDL_Event *sdlevt) {
+    switch (sdlevt->type) {
+    case SDL_VIDEORESIZE:
+        Resize(sdlevt->resize.w, sdlevt->resize.h, PR_FALSE);
+        Redraw();
+        break;
+    case WEBOS_EVENT_REDRAW:
+        Redraw();
+        break;
+    case SDL_KEYDOWN:
+    case SDL_KEYUP:
+        gLastInputEventTime = PR_IntervalToMicroseconds(PR_IntervalNow());
+        OnKeyEvent(sdlevt->key);
+        break;
+    }
+}
+
+void
+nsWindow::DispatchKeyEvent(PRUint32 msg, SDL_keysym &keysym)
+{
+    nsKeyEvent event(PR_TRUE, msg, this);
+
+    PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Got key %d (meta is %d)", event.charCode, gMeta));
+    if (gMeta) {
+        switch (keysym.sym) {
+        case SDLK_BACKSPACE:
+            event.keyCode = NS_VK_BACK;
+            gMeta = 0;
+            gShift = 0;
+            break;
+        case SDLK_RETURN:
+            event.keyCode = NS_VK_RETURN;
+            gMeta = 0;
+            gShift = 0;
+            break;
+        case SDLK_SPACE:
+            event.charCode = ' ';
+            break;
+        case SDLK_COMMA:
+            event.charCode = '_';
+            break;
+        case SDLK_PERIOD:
+            event.charCode = '.';
+            break;
+        case SDLK_AT:
+            event.charCode = '0';
+            break;
+        case SDLK_a:
+            event.charCode = '&';
+            break;
+        case SDLK_b:
+            event.charCode = '#';
+            break;
+        case SDLK_c:
+            event.charCode = '8';
+            break;
+        case SDLK_d:
+            event.charCode = '4';
+            break;
+        case SDLK_e:
+            event.charCode = '1';
+            break;
+        case SDLK_f:
+            event.charCode = '5';
+            break;
+        case SDLK_g:
+            event.charCode = '6';
+            break;
+        case SDLK_h:
+            event.charCode = '$';
+            break;
+        case SDLK_i:
+            event.charCode = '%';
+            break;
+        case SDLK_j:
+            event.charCode = '!';
+            break;
+        case SDLK_k:
+            event.charCode = ':';
+            break;
+        case SDLK_l:
+            event.charCode = '\'';
+            break;
+        case SDLK_m:
+            event.charCode = ';';
+            break;
+        case SDLK_n:
+            event.charCode = '?';
+            break;
+        case SDLK_o:
+            event.charCode = '"';
+            break;
+        case SDLK_p:
+            event.charCode = '=';
+            break;
+        case SDLK_q:
+            event.charCode = '/';
+            break;
+        case SDLK_r:
+            event.charCode = '2';
+            break;
+        case SDLK_s:
+            event.charCode = '-';
+            break;
+        case SDLK_t:
+            event.charCode = '3';
+            break;
+        case SDLK_u:
+            event.charCode = ')';
+            break;
+        case SDLK_v:
+            event.charCode = '9';
+            break;
+        case SDLK_w:
+            event.charCode = '+';
+           break;
+        case SDLK_x:
+            event.charCode = '7';
+            break;
+        case SDLK_y:
+            event.charCode = '(';
+            break;
+        case SDLK_z:
+            event.charCode = '*';
+            break;
+        default:
+            PR_LOG(gWindowEventLog, PR_LOG_ERROR, ("Unknown key code %d", keysym.sym));
+            return;
+        }
+    }
+    else {
+        switch (keysym.sym) {
+        case SDLK_BACKSPACE:
+            event.keyCode = NS_VK_BACK;
+            gMeta = 0;
+            gShift = 0;
+            break;
+        case SDLK_RETURN:
+            event.keyCode = NS_VK_RETURN;
+            gMeta = 0;
+            gShift = 0;
+            break;
+        case SDLK_SPACE:
+            event.charCode = ' ';
+            break;
+        case SDLK_COMMA:
+            event.charCode = ',';
+            break;
+        case SDLK_PERIOD:
+            event.charCode = '.';
+            break;
+        case SDLK_AT:
+            event.charCode = '@';
+            break;
+        case SDLK_a:
+        case SDLK_b:
+        case SDLK_c:
+        case SDLK_d:
+        case SDLK_e:
+        case SDLK_f:
+        case SDLK_g:
+        case SDLK_h:
+        case SDLK_i:
+        case SDLK_j:
+        case SDLK_k:
+        case SDLK_l:
+        case SDLK_m:
+        case SDLK_n:
+        case SDLK_o:
+        case SDLK_p:
+        case SDLK_q:
+        case SDLK_r:
+        case SDLK_s:
+        case SDLK_t:
+        case SDLK_u:
+        case SDLK_v:
+        case SDLK_w:
+        case SDLK_x:
+        case SDLK_y:
+        case SDLK_z:
+            event.charCode = keysym.sym;
+            if (gShift) {
+                event.charCode -= 32;
+            }
+            break;
+        default:
+            PR_LOG(gWindowEventLog, PR_LOG_ERROR, ("Unknown key code %d", keysym.sym));
+            return;
+        }
+    }
+
+    event.isShift = PR_FALSE;
+    event.isControl = PR_FALSE;
+    event.isAlt = PR_FALSE;
+    event.isMeta = PR_FALSE;
+    event.time = PR_Now() / 1000;
+
+    DispatchEvent(&event);
+}
+
+void
+nsWindow::DispatchCommandEvent(nsIAtom *command)
+{
+    nsCommandEvent event(PR_TRUE, nsWidgetAtoms::onAppCommand, command, this);
+    event.time = PR_Now() / 1000;
+    DispatchEvent(&event);
+}
+
+static double
+getDistance(nsIntPoint* points, PRUint32 count)
+{
+    // Only for 2 button gesture right now
+    double deltaX = points[1].x - points[0].x;
+    double deltaY = points[1].y - points[0].y;
+    return sqrt(deltaX * deltaX + deltaY * deltaY);
+}
+
+void
+nsWindow::OnGestureStart(nsIntPoint& center, nsIntPoint* points, PRUint32 count)
+{
+    if (count != 2)
+        return;
+
+    mGestureDistance = getDistance(points, count);
+
+    nsIntPoint offset = WidgetToScreenOffset();
+
+    nsSimpleGestureEvent event(PR_TRUE, NS_SIMPLE_GESTURE_MAGNIFY_START, this, 0, 0);
+    event.time = PR_Now() / 1000;
+    event.refPoint.x = center.x - offset.x;
+    event.refPoint.y = center.y - offset.y;
+    PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("OnGestureStart %dx%d %f", center.x, center.y, mGestureDistance));
+
+    DispatchEvent(&event);
+
+    OnGestureMove(center, points, count);
+}
+
+void
+nsWindow::OnGestureMove(nsIntPoint& center, nsIntPoint* points, PRUint32 count)
+{
+    if (count != 2)
+        return;
+
+    double distance = getDistance(points, count);
+
+    nsIntPoint offset = WidgetToScreenOffset();
+
+    nsSimpleGestureEvent event(PR_TRUE, NS_SIMPLE_GESTURE_MAGNIFY_UPDATE, this, 0, distance - mGestureDistance);
+    event.time = PR_Now() / 1000;
+    event.refPoint.x = center.x - offset.x;
+    event.refPoint.y = center.y - offset.y;
+    PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("OnGestureMove %dx%d %f", center.x, center.y, distance));
+
+    DispatchEvent(&event);
+    mGestureDistance = distance;
+}
+
+void
+nsWindow::OnGestureEnd(PRUint32 count)
+{
+    if (count != 2)
+        return;
+
+    nsSimpleGestureEvent event(PR_TRUE, NS_SIMPLE_GESTURE_MAGNIFY, this, 0, 0);
+    event.time = PR_Now() / 1000;
+    PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("OnGestureEnd"));
+
+    DispatchEvent(&event);
+}
+
+void
+nsWindow::OnKeyEvent(SDL_KeyboardEvent &keyevt)
+{
+    switch (keyevt.keysym.sym) {
+    case SDLK_RALT:
+        if (keyevt.type != SDL_KEYDOWN)
+            return;
+        gShift = 0;
+        gMeta = (gMeta + 1) % 3;
+        return;
+    case SDLK_LSHIFT:
+        if (keyevt.type != SDL_KEYDOWN)
+            return;
+        gMeta = 0;
+        gShift = (gShift + 1) % 3;
+        return;
+    case PDLK_GESTURE_BACK:
+        if (keyevt.type != SDL_KEYDOWN)
+            return;
+        DispatchCommandEvent(nsWidgetAtoms::Back);
+        return;
+    case PDLK_GESTURE_FORWARD:
+        if (keyevt.type != SDL_KEYDOWN)
+            return;
+        DispatchCommandEvent(nsWidgetAtoms::Forward);
+        return;
+    case PDLK_GESTURE_AREA:
+        return;
+    default:
+        break;
+    }
+
+    PRUint32 msg;
+    switch (keyevt.type) {
+    case SDL_KEYDOWN:
+        msg = NS_KEY_DOWN;
+        break;
+    case SDL_KEYUP:
+        msg = NS_KEY_UP;
+        break;
+    default:
+        PR_LOG(gWindowEventLog, PR_LOG_WARNING, ("Unknown key action event %d", keyevt.type));
+        return;
+    }
+
+    DispatchKeyEvent(msg, keyevt.keysym);
+
+    if (msg == NS_KEY_DOWN) {
+        DispatchKeyEvent(NS_KEY_PRESS, keyevt.keysym);
+    }
+    else {
+        if (gMeta == 1) {
+            gMeta = 0;
+        }
+        if (gShift == 1) {
+            gShift = 0;
+        }
+    }
+}
+
+void
+nsWindow::OnMouseEvent(PRUint32 msg, nsIntPoint pt)
+{
+    nsIntPoint offset = WidgetToScreenOffset();
+    pt.x -= offset.x;
+    pt.y -= offset.y;
+
+    PR_LOG(gWindowEventLog, PR_LOG_DEBUG,
+           ("Window 0x%08x Mouse event dispatched to % 3d,% 3d", (void*)this, pt.x, pt.y));
+
+    if (pt.x < 0 || pt.x >= mBounds.width ||
+        pt.y < 0 || pt.y >= mBounds.height)
+    {
+        PR_LOG(gWindowEventLog, PR_LOG_WARNING,
+               ("Event is out of bounds % 3dx% 3d", (void*)this, mBounds.width, mBounds.height));
+        return;
+    }
+
+    nsMouseEvent event(PR_TRUE, msg, this, nsMouseEvent::eReal, nsMouseEvent::eNormal);
+    InitEvent(event, &pt);
+    event.time = PR_Now() / 1000;
+
+    if (msg != NS_MOUSE_MOVE)
+    {
+        PRBool resetClicks = !mLastClickTime || ((gLastInputEventTime - mLastClickTime) > 500000);
+        if (msg == NS_MOUSE_BUTTON_DOWN && resetClicks)
+            mClickCount = 0;
+
+        mLastClickPosition = pt;
+        mLastClickTime = gLastInputEventTime;
+        if (msg == NS_MOUSE_BUTTON_DOWN) {
+            mClickCount++;
+        }
+
+        event.button = nsMouseEvent::eLeftButton;
+        event.clickCount = mClickCount;
+    }
+
+    PR_LOG(gWindowEventLog, PR_LOG_DEBUG, ("Dispatching mouse event %d with click count %d", msg, mClickCount));
+    DispatchEvent(&event);
+}
+
+void
+nsWindow::DrawTo(gfxASurface *targetSurface)
+{
+    if (!mIsVisible) {
+        PR_LOG(gWindowLog, PR_LOG_WARNING, ("Not drawing invisible child window 0x%08x", (void*)this));
+        return;
+    }
+
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x DrawTo", (void*)this));
+
+    nsEventStatus status;
+    nsIntRect boundsRect(0, 0, mBounds.width, mBounds.height);
+
+    nsPaintEvent event(PR_TRUE, NS_PAINT, this);
+    event.region = boundsRect;
+
+    nsRefPtr<gfxContext> ctx = new gfxContext(targetSurface);
+    ctx->SetMatrix(nsAppShell::gAppShell->mScreenTransform);
+
+    {
+        AutoLayerManagerSetup setupLayerManager(this, ctx, BasicLayerManager::BUFFER_NONE);
+        status = DispatchEvent(&event);
+    }
+
+    gfxPoint offset = targetSurface->GetDeviceOffset();
+
+    for (PRUint32 i = 0; i < mChildren.Length(); ++i) {
+        if (mChildren[i]->mBounds.IsEmpty() ||
+            !mChildren[i]->mBounds.Intersects(boundsRect)) {
+            continue;
+        }
+
+        if (targetSurface)
+            targetSurface->SetDeviceOffset(offset + gfxPoint(mChildren[i]->mBounds.x,
+                                                             mChildren[i]->mBounds.y));
+
+        mChildren[i]->DrawTo(targetSurface);
+    }
+
+    if (targetSurface)
+        targetSurface->SetDeviceOffset(offset);
+
+    return;
+}
+
+void
+nsWindow::Redraw()
+{
+    if (!IsTopLevel()) {
+        FindTopLevel()->Redraw();
+        return;
+    }
+
+    if (!mIsVisible) {
+        PR_LOG(gWindowLog, PR_LOG_WARNING,
+               ("Window 0x%08x Redraw for an invisible window, ignoring", (void*)this));
+        DumpWindows();
+        return;
+    }
+
+    PR_LOG(gWindowLog, PR_LOG_DEBUG, ("Window 0x%08x Redraw", (void*)this));
+
+    SDL_Surface *surface = SDL_GetVideoSurface();
+    if (!surface) {
+        PR_LOG(gWindowLog, PR_LOG_ERROR, ("Window 0x%08x Failed to get video surface", (void*)this));
+        return;
+    }
+
+    gfxASurface::gfxImageFormat format;
+    switch (surface->format->BitsPerPixel) {
+    case 24:
+        format = gfxASurface::ImageFormatRGB24;
+        break;
+    case 32:
+        format = gfxASurface::ImageFormatARGB32;
+        break;
+    default:
+        PR_LOG(gWindowLog, PR_LOG_ERROR, ("Window 0x%08x Invalid pixel format bpp %d",
+                                          (void*)this, surface->format->BitsPerPixel));
+        return;
+    }
+
+    if (SDL_LockSurface(surface) < 0) {
+        PR_LOG(gWindowLog, PR_LOG_ERROR, ("Window 0x%08x Failed to lock surface", (void*)this));
+        return;
+    }
+
+    gfxIntSize size(surface->w, surface->h);
+    nsRefPtr<gfxImageSurface> targetSurface = new gfxImageSurface((unsigned char*)surface->pixels, size, surface->pitch, format);
+    DrawTo(targetSurface);
+    SDL_UnlockSurface(surface);
+    SDL_Flip(surface);
+}
+
+void
+nsWindow::OnSizeChanged(const gfxIntSize& aSize)
+{
+    int w = aSize.width;
+    int h = aSize.height;
+
+    PR_LOG(gWindowLog, PR_LOG_DEBUG,
+           ("Window 0x%08x OnSizeChanged [% 3dx% 3d]", (void*)this, w, h));
+
+    nsSizeEvent event(PR_TRUE, NS_SIZE, this);
+    InitEvent(event);
+
+    nsIntRect wsz(0, 0, w, h);
+    event.windowSize = &wsz;
+    event.mWinWidth = w;
+    event.mWinHeight = h;
+
+    mBounds.width = w;
+    mBounds.height = h;
+
+    DispatchEvent(&event);
+}
+
+void
+nsWindow::InitEvent(nsGUIEvent& event, nsIntPoint* aPoint)
+{
+    if (aPoint) {
+        event.refPoint.x = aPoint->x;
+        event.refPoint.y = aPoint->y;
+    } else {
+        event.refPoint.x = 0;
+        event.refPoint.y = 0;
+    }
+
+    event.time = PR_Now() / 1000;
+}
+
+void *
+nsWindow::GetNativeData(PRUint32 aDataType)
+{
+    switch (aDataType) {
+        // used by GLContextProviderEGL, NULL is EGL_DEFAULT_DISPLAY
+        case NS_NATIVE_DISPLAY:
+            return NULL;
+
+        case NS_NATIVE_WIDGET:
+            return (void *) this;
+    }
+
+    return nsnull;
+}
+
+nsresult
+nsWindow::GetCurrentOffset(PRUint32 &aOffset, PRUint32 &aLength)
+{
+    nsQueryContentEvent event(PR_TRUE, NS_QUERY_SELECTED_TEXT, this);
+    DispatchEvent(&event);
+
+    if (!event.mSucceeded)
+        return NS_ERROR_FAILURE;
+
+    aOffset = event.mReply.mOffset;
+    aLength = event.mReply.mString.Length();
+    return NS_OK;
+}
+
+nsresult
+nsWindow::DeleteRange(int aOffset, int aLen)
+{
+    nsSelectionEvent selectEvent(PR_TRUE, NS_SELECTION_SET, this);
+    selectEvent.mOffset = aOffset;
+    selectEvent.mLength = aLen;
+    DispatchEvent(&selectEvent);
+    NS_ENSURE_TRUE(selectEvent.mSucceeded, NS_ERROR_FAILURE);
+
+    nsContentCommandEvent event(PR_TRUE, NS_CONTENT_COMMAND_DELETE, this);
+    DispatchEvent(&event);
+    NS_ENSURE_TRUE(event.mSucceeded, NS_ERROR_FAILURE);
+
+    return NS_OK;
+}
+
+nsWindow *
+nsWindow::FindWindowForPoint(const nsIntPoint& pt)
+{
+    if (!mBounds.Contains(pt))
+        return nsnull;
+
+    // children mBounds are relative to their parent
+    nsIntPoint childPoint(pt.x - mBounds.x, pt.y - mBounds.y);
+
+    for (PRUint32 i = 0; i < mChildren.Length(); ++i) {
+        if (mChildren[i]->mBounds.Contains(childPoint))
+            return mChildren[i]->FindWindowForPoint(childPoint);
+    }
+
+    return this;
+}
diff --git a/widget/src/webos/nsWindow.h b/widget/src/webos/nsWindow.h
new file mode 100644
--- /dev/null
+++ b/widget/src/webos/nsWindow.h
@@ -0,0 +1,189 @@
+/* -*- Mode: c++; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Android code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *   Dave Townsend <dtownsend@oxymoronical.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef NSWINDOW_H_
+#define NSWINDOW_H_
+
+#include "nsBaseWidget.h"
+#include "gfxPoint.h"
+
+#include "nsTArray.h"
+
+#include "SDL.h"
+
+class gfxASurface;
+
+class nsWindow :
+    public nsBaseWidget
+{
+public:
+    nsWindow();
+    virtual ~nsWindow();
+
+    NS_DECL_ISUPPORTS_INHERITED
+
+    static void OnGlobalSDLEvent(SDL_Event *sdlevt);
+
+    nsWindow* FindWindowForPoint(const nsIntPoint& pt);
+
+    void OnSDLEvent(SDL_Event *sdlevt);
+
+    void Redraw();
+
+    void InitEvent(nsGUIEvent& event, nsIntPoint* aPoint = 0);
+
+    //
+    // nsIWidget
+    //
+
+    NS_IMETHOD Create(nsIWidget *aParent,
+                      nsNativeWidget aNativeParent,
+                      const nsIntRect &aRect,
+                      EVENT_CALLBACK aHandleEventFunction,
+                      nsIDeviceContext *aContext,
+                      nsIAppShell *aAppShell,
+                      nsIToolkit *aToolkit,
+                      nsWidgetInitData *aInitData);
+    NS_IMETHOD Destroy(void);
+    NS_IMETHOD ConfigureChildren(const nsTArray<nsIWidget::Configuration>&);
+    NS_IMETHOD SetParent(nsIWidget* aNewParent);
+    virtual nsIWidget *GetParent(void);
+    NS_IMETHOD Show(PRBool aState);
+    NS_IMETHOD SetModal(PRBool aModal);
+    NS_IMETHOD IsVisible(PRBool & aState);
+    NS_IMETHOD ConstrainPosition(PRBool aAllowSlop,
+                                 PRInt32 *aX,
+                                 PRInt32 *aY);
+    NS_IMETHOD Move(PRInt32 aX,
+                    PRInt32 aY);
+    NS_IMETHOD Resize(PRInt32 aWidth,
+                      PRInt32 aHeight,
+                      PRBool  aRepaint);
+    NS_IMETHOD Resize(PRInt32 aX,
+                      PRInt32 aY,
+                      PRInt32 aWidth,
+                      PRInt32 aHeight,
+                      PRBool aRepaint);
+    NS_IMETHOD SetZIndex(PRInt32 aZIndex);
+    NS_IMETHOD PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
+                           nsIWidget *aWidget,
+                           PRBool aActivate);
+    NS_IMETHOD SetSizeMode(PRInt32 aMode);
+    NS_IMETHOD Enable(PRBool aState);
+    NS_IMETHOD IsEnabled(PRBool *aState);
+    NS_IMETHOD Invalidate(const nsIntRect &aRect,
+                          PRBool aIsSynchronous);
+    NS_IMETHOD Update();
+    void Scroll(const nsIntPoint&,
+                const nsTArray<nsIntRect>&,
+                const nsTArray<nsIWidget::Configuration>&);
+    NS_IMETHOD SetFocus(PRBool aRaise = PR_FALSE);
+    NS_IMETHOD GetScreenBounds(nsIntRect &aRect);
+    virtual nsIntPoint WidgetToScreenOffset();
+    NS_IMETHOD DispatchEvent(nsGUIEvent *aEvent, nsEventStatus &aStatus);
+    nsEventStatus DispatchEvent(nsGUIEvent *aEvent);
+    NS_IMETHOD SetWindowClass(const nsAString& xulWinType);
+
+
+
+    NS_IMETHOD SetForegroundColor(const nscolor &aColor) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD SetBackgroundColor(const nscolor &aColor) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD SetCursor(nsCursor aCursor) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD SetCursor(imgIContainer* aCursor,
+                         PRUint32 aHotspotX,
+                         PRUint32 aHotspotY) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD SetHasTransparentBackground(PRBool aTransparent) { return NS_OK; }
+    NS_IMETHOD GetHasTransparentBackground(PRBool& aTransparent) { aTransparent = PR_FALSE; return NS_OK; }
+    NS_IMETHOD HideWindowChrome(PRBool aShouldHide) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD MakeFullScreen(PRBool aFullScreen) { return NS_ERROR_NOT_IMPLEMENTED; }
+    virtual void* GetNativeData(PRUint32 aDataType);
+    NS_IMETHOD SetTitle(const nsAString& aTitle) { return NS_OK; }
+    NS_IMETHOD SetIcon(const nsAString& aIconSpec) { return NS_OK; }
+    NS_IMETHOD EnableDragDrop(PRBool aEnable) { return NS_OK; }
+    NS_IMETHOD CaptureMouse(PRBool aCapture) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD CaptureRollupEvents(nsIRollupListener *aListener,
+                                   nsIMenuRollup *aMenuRollup,
+                                   PRBool aDoCapture,
+                                   PRBool aConsumeRollupEvent) { return NS_ERROR_NOT_IMPLEMENTED; }
+
+    NS_IMETHOD GetAttention(PRInt32 aCycleCount) { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVertical) { return NS_ERROR_NOT_IMPLEMENTED; }
+
+    NS_IMETHOD SetIMEEnabled(PRUint32 aState) { return NS_ERROR_NOT_IMPLEMENTED; };
+    NS_IMETHOD GetIMEEnabled(PRUint32* aState) { return NS_ERROR_NOT_IMPLEMENTED; };
+
+    gfxASurface* GetThebesSurface();
+
+protected:
+    void BringToFront();
+    nsWindow *FindTopLevel();
+    void DrawTo(gfxASurface *targetSurface);
+    PRBool IsTopLevel();
+    nsresult GetCurrentOffset(PRUint32 &aOffset, PRUint32 &aLength);
+    nsresult DeleteRange(int aOffset, int aLen);
+
+    PRPackedBool mIsVisible;
+    nsContentType mContentType;
+    nsTArray<nsWindow*> mChildren;
+    nsWindow* mParent;
+
+    PRUint32 mClickCount;
+    PRUint32 mLastClickTime;
+    nsIntPoint mLastClickPosition;
+    double mGestureDistance;
+
+    void DispatchCommandEvent(nsIAtom *command);
+    void OnMouseEvent(PRUint32 event, nsIntPoint pt);
+    void DispatchKeyEvent(PRUint32 msg, SDL_keysym &keysym);
+    void OnKeyEvent(SDL_KeyboardEvent &keyevt);
+    void OnSizeChanged(const gfxIntSize& aSize);
+    void OnGestureStart(nsIntPoint& center, nsIntPoint* points, PRUint32 count);
+    void OnGestureMove(nsIntPoint& center, nsIntPoint* points, PRUint32 count);
+    void OnGestureEnd(PRUint32 count);
+
+    static PRUint32 mButtonCount;
+    static nsRefPtr<nsWindow> mGestureWindow;
+
+    static nsIntPoint TranslateScreenPoint(int x, int y);
+
+    static void DumpWindows();
+    static void DumpWindows(const nsTArray<nsWindow*>& wins, int indent = 0);
+    static void LogWindow(nsWindow *win, int index, int indent);
+};
+
+#endif /* NSWINDOW_H_ */
